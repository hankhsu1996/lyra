feature: compound_assignment
description: Tests for compound assignment operators (+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, etc.)

cases:
  - name: add_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 10;
          x += 5;
        end
      endmodule
    expect:
      variables:
        x: 15

  - name: sub_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 20;
          x -= 7;
        end
      endmodule
    expect:
      variables:
        x: 13

  - name: mul_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 6;
          x *= 7;
        end
      endmodule
    expect:
      variables:
        x: 42

  - name: div_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 100;
          x /= 4;
        end
      endmodule
    expect:
      variables:
        x: 25

  - name: mod_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 17;
          x %= 5;
        end
      endmodule
    expect:
      variables:
        x: 2

  - name: and_assign
    sv: |
      module Test;
        logic [7:0] x;
        initial begin
          x = 8'b11110000;
          x &= 8'b10101010;
        end
      endmodule
    expect:
      variables:
        x: 160 # 0b10100000 = 160

  - name: or_assign
    sv: |
      module Test;
        logic [7:0] x;
        initial begin
          x = 8'b11110000;
          x |= 8'b00001111;
        end
      endmodule
    expect:
      variables:
        x: 255

  - name: xor_assign
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          x ^= 3;  // 5 ^ 3 = 6
        end
      endmodule
    expect:
      variables:
        x: 6

  - name: left_shift_assign
    sv: |
      module Test;
        logic [7:0] x;
        initial begin
          x = 8'd1;
          x <<= 4;
        end
      endmodule
    expect:
      variables:
        x: 16

  - name: right_shift_assign
    sv: |
      module Test;
        logic [7:0] x;
        initial begin
          x = 8'd64;
          x >>= 2;
        end
      endmodule
    expect:
      variables:
        x: 16

  - name: chained_compound
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          x += 3;
          x *= 2;
        end
      endmodule
    expect:
      variables:
        x: 16

  - name: array_element_compound
    sv: |
      module Test;
        int arr[3];
        int result;
        initial begin
          arr[0] = 10;
          arr[1] = 20;
          arr[2] = 30;
          arr[1] += 5;
          result = arr[1];
        end
      endmodule
    expect:
      variables:
        result: 25

  - name: compound_with_expression
    sv: |
      module Test;
        int x, y;
        initial begin
          x = 10;
          y = 3;
          x += y * 2;  // x = x + (y * 2) = 10 + 6 = 16
        end
      endmodule
    expect:
      variables:
        x: 16
        y: 3

  - name: side_effect_index_postinc
    description: Verifies index with side-effect (i++) is evaluated only once for read-modify-write
    sv: |
      module Test;
        int arr[3];
        int i;
        int r0, r1, r2;  // Result variables
        initial begin
          arr[0] = 100;
          arr[1] = 200;
          arr[2] = 300;
          i = 1;
          arr[i++] += 10;  // Should: read arr[1]=200, write 210 to arr[1], i becomes 2
          r0 = arr[0];
          r1 = arr[1];
          r2 = arr[2];
        end
      endmodule
    expect:
      variables:
        r0: 100 # arr[0] unchanged
        r1: 210 # arr[1] = 200 + 10
        r2: 300 # arr[2] unchanged
        i: 2 # i incremented once

  - name: side_effect_index_preinc
    description: Verifies index with pre-increment (++i) is evaluated only once
    sv: |
      module Test;
        int arr[3];
        int i;
        int r0, r1, r2;  // Result variables
        initial begin
          arr[0] = 100;
          arr[1] = 200;
          arr[2] = 300;
          i = 0;
          arr[++i] += 50;  // Should: i becomes 1, read arr[1]=200, write 250 to arr[1]
          r0 = arr[0];
          r1 = arr[1];
          r2 = arr[2];
        end
      endmodule
    expect:
      variables:
        r0: 100 # arr[0] unchanged
        r1: 250 # arr[1] = 200 + 50
        r2: 300 # arr[2] unchanged
        i: 1 # i incremented once

  - name: range_select_xor_assign
    description: Compound assignment to constant range select (x[a:b] ^= ...)
    sv: |
      module Test;
        logic [19:0] key_out;
        logic [4:0] round_idx;
        initial begin
          key_out = 20'h12345;
          round_idx = 5'b10101;
          key_out[19:15] ^= round_idx;
        end
      endmodule
    expect:
      variables:
        key_out: 0xBA345

  - name: range_select_or_assign
    description: Compound OR assignment to range select
    sv: |
      module Test;
        logic [15:0] x;
        initial begin
          x = 16'h0030;
          x[7:4] |= 4'b1010;
        end
      endmodule
    expect:
      variables:
        x: 0x00B0 # 0011 | 1010 = 1011

  - name: range_select_add_assign
    description: Compound add assignment to range select
    sv: |
      module Test;
        logic [15:0] x;
        initial begin
          x = 16'h0050;
          x[7:4] += 4'd3;
        end
      endmodule
    expect:
      variables:
        x: 0x0080 # 5 + 3 = 8

  - name: indexed_partselect_dynamic_add_assign
    description: Compound assignment to indexed part-select with dynamic index
    sv: |
      module Test;
        logic [15:0] x;
        int i;
        initial begin
          x = 16'h0000;
          i = 4;
          x[i+:4] += 4'd5;  // bits [7:4] get 5 added
        end
      endmodule
    expect:
      variables:
        x: 0x0050

  - name: indexed_partselect_local_var
    description: Compound assignment to indexed part-select on local variable
    sv: |
      module Test;
        int result;
        initial begin
          logic [15:0] data;
          int idx;
          data = 16'h0000;
          idx = 8;
          data[idx+:4] += 4'd10;  // bits [11:8] get 10 added
          result = data;
        end
      endmodule
    expect:
      variables:
        result: 0x0A00

  - name: packed_element_dynamic_add_assign
    description: Compound assignment to packed array element with dynamic index
    sv: |
      module Test;
        logic [7:0] x;
        int i;
        initial begin
          x = 8'b00000000;
          i = 3;
          x[i] += 1'b1;  // bit 3 gets 1 added
        end
      endmodule
    expect:
      variables:
        x: 0x08

  - name: indexed_partselect_read_in_function
    description: Read from indexed part-select with dynamic index in user function (GuardedUse)
    sv: |
      module Test;
        int result;

        function automatic int read_slice(input int idx);
          logic [15:0] data;
          data = 16'hABCD;
          return data[idx+:4];  // dynamic indexed part-select read -> GuardedUse
        endfunction

        initial begin
          result = read_slice(4);  // reads bits [7:4] = 0xC
        end
      endmodule
    expect:
      variables:
        result: 0x0C

  - name: packed_element_read_in_function
    description: Read from packed element with dynamic index in user function (GuardedUse)
    sv: |
      module Test;
        int result;

        function automatic int read_bit(input int idx);
          logic [7:0] data;
          data = 8'b10101010;
          return data[idx];  // dynamic packed element read -> GuardedUse
        endfunction

        initial begin
          result = read_bit(3);  // bit 3 = 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: indexed_partselect_on_int_parameter
    description: Read indexed part-select from int function parameter (tests PlaceCollector for RvalueInfo)
    sv: |
      module Test;
        int result;

        function automatic int read_param_slice(input int data, input int idx);
          return data[idx+:4];  // parameter accessed ONLY via indexed part-select
        endfunction

        initial begin
          result = read_param_slice(32'hDEADBEEF, 4);  // bits [7:4] = 0xE
        end
      endmodule
    expect:
      variables:
        result: 0x0E

  - name: packed_element_on_int_parameter
    description: Read packed element from int function parameter (tests PlaceCollector for RvalueInfo)
    sv: |
      module Test;
        int result;

        function automatic int read_param_bit(input int data, input int idx);
          return data[idx];  // parameter accessed ONLY via packed element select
        endfunction

        initial begin
          result = read_param_bit(32'b10101010, 3);  // bit 3 = 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: queue_pop_in_function
    description: Queue pop_front on local queue inside user function
    sv: |
      module Test;
        int result;

        function automatic int pop_local();
          int q[$];  // Local queue in function
          q = '{10, 20, 30};
          return q.pop_front();  // pop from local queue
        endfunction

        initial begin
          result = pop_local();
        end
      endmodule
    expect:
      variables:
        result: 10
