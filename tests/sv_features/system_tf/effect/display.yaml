feature: display
description: Tests for $display system task output

cases:
  - name: display_string
    sv: |
      module Test;
        initial $display("Hello World");
      endmodule
    expect:
      stdout: "Hello World\n"

  - name: display_empty
    sv: |
      module Test;
        initial $display();
      endmodule
    expect:
      stdout: "\n"

  - name: display_integer
    sv: |
      module Test;
        int x;
        initial begin
          x = 42;
          $display("%d", x);
        end
      endmodule
    expect:
      stdout: "42\n"

  - name: display_multiple_values
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 10;
          b = 20;
          $display("a=%d b=%d", a, b);
        end
      endmodule
    expect:
      stdout: "a=10 b=20\n"

  # LRM 21.2.1.2: For %h/%b/%o, leading zeros are always displayed based on bit width.
  # int is 32 bits = 8 hex digits.
  - name: display_hex_format
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $display("%h", x);
        end
      endmodule
    expect:
      stdout: "000000ff\n"

  # LRM 21.2.1.2: int is 32 bits = 32 binary digits.
  - name: display_binary_format
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          $display("%b", x);
        end
      endmodule
    expect:
      stdout: "00000000000000000000000000000101\n"

  - name: display_multiple_calls
    sv: |
      module Test;
        initial begin
          $display("line 1");
          $display("line 2");
        end
      endmodule
    expect:
      stdout: |
        line 1
        line 2

  - name: display_no_format_string
    sv: |
      module Test;
        int x;
        initial begin
          x = 99;
          $display(x);
        end
      endmodule
    expect:
      stdout: "99\n"

  - name: display_contains_check
    sv: |
      module Test;
        initial begin
          $display("prefix data suffix");
          $display("more output");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "data"
          - "more"

  - name: display_real_default_precision
    sv: |
      module Test;
        real x;
        initial begin
          x = 1.5;
          $display("%f", x);
        end
      endmodule
    expect:
      stdout: "1.500000\n"

  - name: display_real_with_precision
    sv: |
      module Test;
        real x;
        initial begin
          x = 3.14159;
          $display("%.3f", x);
        end
      endmodule
    expect:
      stdout: "3.142\n"

  - name: display_integer_width
    sv: |
      module Test;
        int x;
        initial begin
          x = 42;
          $display("%5d", x);
        end
      endmodule
    expect:
      stdout: "   42\n"

  - name: display_integer_zero_pad
    sv: |
      module Test;
        int x;
        initial begin
          x = 42;
          $display("%05d", x);
        end
      endmodule
    expect:
      stdout: "00042\n"

  - name: display_hex_zero_pad
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $display("%04h", x);
        end
      endmodule
    expect:
      stdout: "00ff\n"

  # Explicit width without 0 prefix uses space-padding (not zero-padding)
  # %4h = width 4, space-padded; %04h = width 4, zero-padded
  - name: display_hex_width_no_zero_prefix
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $display("[%4h]", x);
        end
      endmodule
    expect:
      stdout: "[  ff]\n"

  - name: display_binary_zero_pad
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          $display("%08b", x);
        end
      endmodule
    expect:
      stdout: "00000101\n"

  - name: display_string_width
    sv: |
      module Test;
        string s;
        initial begin
          s = "hi";
          $display("[%5s]", s);
        end
      endmodule
    expect:
      stdout: "[   hi]\n"

  - name: display_string_left_align
    sv: |
      module Test;
        string s;
        initial begin
          s = "hi";
          $display("[%-5s]", s);
        end
      endmodule
    expect:
      stdout: "[hi   ]\n"

  # LRM 21.2.1.2: %0h displays with minimum width, no leading zeros
  - name: display_hex_minimal
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $display("%0h", x);
        end
      endmodule
    expect:
      stdout: "ff\n"

  # LRM 21.2.1.2: %0b displays with minimum width, no leading zeros
  - name: display_binary_minimal
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          $display("%0b", x);
        end
      endmodule
    expect:
      stdout: "101\n"

  # LRM 21.2.1.2: %0o displays with minimum width, no leading zeros
  - name: display_octal_minimal
    sv: |
      module Test;
        int x;
        initial begin
          x = 8;
          $display("%0o", x);
        end
      endmodule
    expect:
      stdout: "10\n"

  # LRM 21.2.1.2: %0d displays with minimum width, no leading spaces
  - name: display_decimal_minimal
    sv: |
      module Test;
        int x;
        initial begin
          x = 42;
          $display("%0d", x);
        end
      endmodule
    expect:
      stdout: "42\n"

  # LRM 21.2.1.2: Different bit widths show different auto-sizing
  - name: display_hex_different_widths
    sv: |
      module Test;
        byte byte_val;
        shortint short_val;
        int int_val;
        initial begin
          byte_val = 8'hAB;
          short_val = 16'h00FF;
          int_val = 255;
          $display("%h %h %h", byte_val, short_val, int_val);
        end
      endmodule
    expect:
      stdout: "ab 00ff 000000ff\n"

  # $write variants (no newline)
  - name: write_no_newline
    sv: |
      module Test;
        initial begin
          $write("no");
          $write("newline");
        end
      endmodule
    expect:
      stdout: "nonewline"

  - name: write_empty_does_nothing
    sv: |
      module Test;
        initial begin
          $write();
          $write("done");
        end
      endmodule
    expect:
      stdout: "done"

  # LRM 21.2.1.2: $writeh uses hex format with full bit width (32-bit int = 8 hex digits)
  - name: writeh_default_hex
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $writeh(x);
        end
      endmodule
    expect:
      stdout: "000000ff"

  # LRM 21.2.1.2: $writeb uses binary format with full bit width (32-bit int = 32 binary digits)
  - name: writeb_default_binary
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          $writeb(x);
        end
      endmodule
    expect:
      stdout: "00000000000000000000000000000101"

  # LRM 21.2.1.2: $writeo uses octal format with full bit width (32-bit int = 11 octal digits)
  - name: writeo_default_octal
    sv: |
      module Test;
        int x;
        initial begin
          x = 8;
          $writeo(x);
        end
      endmodule
    expect:
      stdout: "00000000010"

  # $display variants (with newline, different default format)
  # LRM 21.2.1.2: $displayh uses hex format with full bit width
  - name: displayh_default_hex
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $displayh(x);
        end
      endmodule
    expect:
      stdout: "000000ff\n"

  # LRM 21.2.1.2: $displayb uses binary format with full bit width
  - name: displayb_default_binary
    sv: |
      module Test;
        int x;
        initial begin
          x = 5;
          $displayb(x);
        end
      endmodule
    expect:
      stdout: "00000000000000000000000000000101\n"

  # LRM 21.2.1.2: $displayo uses octal format with full bit width
  - name: displayo_default_octal
    sv: |
      module Test;
        int x;
        initial begin
          x = 8;
          $displayo(x);
        end
      endmodule
    expect:
      stdout: "00000000010\n"

  # Format string overrides default
  - name: displayh_with_format_uses_format
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $displayh("%d", x);
        end
      endmodule
    expect:
      stdout: "255\n"

  # LRM 21.2.1.2: Format string %h shows full bit width (8 hex digits for 32-bit int)
  - name: writeb_with_format_uses_format
    sv: |
      module Test;
        int x;
        initial begin
          x = 255;
          $writeb("%h", x);
        end
      endmodule
    expect:
      stdout: "000000ff"

  # Multiple values with variant default
  # LRM 21.2.1.2: $displayh auto-formats all integers with full hex width
  - name: displayh_multiple_values
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 10;
          b = 255;
          $displayh(a, b);
        end
      endmodule
    expect:
      stdout: "0000000a000000ff\n"

  # Mixed types - integers use variant format with full width, strings as-is
  # LRM 21.2.1.2: $displayh auto-formats integers with full hex width
  - name: displayh_mixed_types
    sv: |
      module Test;
        int x;
        string s;
        initial begin
          x = 255;
          s = "test";
          $displayh(x, s);
        end
      endmodule
    expect:
      stdout: "000000fftest\n"

  # Wide bit vectors (>64 bits) with decimal format
  # Note: Using 2-state 'bit' type since conversion to 4-state is not yet supported.
  # These tests focus on wide decimal formatting, not 4-state X/Z display semantics.
  - name: wide_decimal_128bit
    sv: |
      module Test;
        bit [127:0] val;
        initial begin
          val = 128'd12345678901234567890;
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "12345678901234567890\n"

  - name: wide_decimal_zero
    sv: |
      module Test;
        bit [127:0] val;
        initial begin
          val = 128'd0;
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "0\n"

  - name: wide_decimal_no_format_string
    sv: |
      module Test;
        bit [127:0] val;
        initial begin
          val = 128'd999999999999999999;
          $display(val);
        end
      endmodule
    expect:
      stdout: "999999999999999999\n"

  - name: wide_decimal_computed
    sv: |
      module Test;
        bit [127:0] val;
        bit [127:0] a, b;
        initial begin
          a = 128'd9000000000000000000;
          b = 128'd1234567890123456789;
          val = a + b;  // Computed value spans >64 bits
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "10234567890123456789\n"

  - name: wide_signed_negative
    sv: |
      module Test;
        bit signed [127:0] val;
        initial begin
          val = -1;
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "-1\n"

  - name: wide_signed_large_negative
    sv: |
      module Test;
        bit signed [127:0] val;
        initial begin
          val = -128'd12345678901234567890;
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "-12345678901234567890\n"

  # 65-bit boundary cases verify top-word masking at the word boundary
  - name: wide_decimal_65bit_boundary
    sv: |
      module Test;
        bit [64:0] val;
        initial begin
          val = 65'h1_FFFF_FFFF_FFFF_FFFF;  // 2^65 - 1
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "36893488147419103231\n"

  - name: wide_decimal_65bit_single_high_bit
    sv: |
      module Test;
        bit [64:0] val;
        initial begin
          val = 65'h1_0000_0000_0000_0000;  // 2^64
          $display("%d", val);
        end
      endmodule
    expect:
      stdout: "18446744073709551616\n"

  - name: char_basic_ascii
    sv: |
      module Test;
        initial $display("%c%c%c", 65, 66, 67);
      endmodule
    expect:
      stdout: "ABC\n"

  - name: char_with_x_bits
    sv: |
      module Test;
        logic [7:0] c;
        initial begin
          c = 8'bxxxx_xxxx;
          $display("%c", c);
        end
      endmodule
    expect:
      stdout: "x\n"

  - name: char_with_z_bits
    sv: |
      module Test;
        logic [7:0] c;
        initial begin
          c = 8'bzzzz_zzzz;
          $display("%c", c);
        end
      endmodule
    expect:
      stdout: "z\n"

  - name: char_mixed_x_z
    description: Partial X in low byte collapses to x
    sv: |
      module Test;
        logic [7:0] c;
        initial begin
          c = 8'b0000_xxxx;
          $display("%c", c);
        end
      endmodule
    expect:
      stdout: "x\n"

  - name: char_extracts_low_8_bits
    description: Only low 8 bits matter for %c
    sv: |
      module Test;
        int x;
        initial begin
          x = 32'hFFFF_0041;  // Low byte is 'A' (0x41)
          $display("%c", x);
        end
      endmodule
    expect:
      stdout: "A\n"

  - name: char_newline
    sv: |
      module Test;
        initial $display("%c", 10);  // ASCII newline
      endmodule
    expect:
      stdout: "\n\n"
