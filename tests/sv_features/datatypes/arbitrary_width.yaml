feature: arbitrary_width_bit_vectors
description: Tests for bit vectors with arbitrary widths (1-64 bits)

cases:
  - name: bit_4_basic
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 5;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 5

  - name: bit_4_overflow
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 15;
          a = a + 1;  // Should wrap to 0
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_8_basic
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 200;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 200

  - name: bit_8_overflow
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 255;
          a = a + 1;  // Should wrap to 0
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_16_basic
    sv: |
      module Test;
        bit [15:0] a;
        int result;
        initial begin
          a = 12345;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 12345

  - name: bit_5_arithmetic
    sv: |
      module Test;
        bit [4:0] a, b, c;
        int result;
        initial begin
          a = 10;
          b = 20;
          c = a + b;  // 30 & 0x1F = 30
          result = c;
        end
      endmodule
    expect:
      variables:
        result: 30

  - name: bit_5_overflow_arithmetic
    sv: |
      module Test;
        bit [4:0] a, b, c;
        int result;
        initial begin
          a = 20;
          b = 20;
          c = a + b;  // 40 & 0x1F = 8
          result = c;
        end
      endmodule
    expect:
      variables:
        result: 8

  - name: logic_signed_4bit
    sv: |
      module Test;
        logic signed [3:0] a;
        int result;
        initial begin
          a = -5;  // 4-bit: 1011 = -5
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -5

  - name: logic_signed_4bit_comparison
    sv: |
      module Test;
        logic signed [3:0] a, b;
        int result;
        initial begin
          a = -8;  // Minimum 4-bit signed value
          b = 7;   // Maximum 4-bit signed value
          result = (a < b) ? 1 : 0;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_12_bitwise
    sv: |
      module Test;
        bit [11:0] a, b, c;
        int result;
        initial begin
          a = 12'hABC;
          b = 12'h123;
          c = a & b;
          result = c;
        end
      endmodule
    expect:
      variables:
        result: 32  # 0xABC & 0x123 = 0x020

  - name: bit_24_basic
    sv: |
      module Test;
        bit [23:0] a;
        int result;
        initial begin
          a = 24'hCAFE12;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 13303314  # 0xCAFE12

  - name: bit_48_basic
    sv: |
      module Test;
        bit [47:0] a;
        longint result;
        initial begin
          a = 48'hDEADBEEF1234;
          result = longint'(a);
        end
      endmodule
    expect:
      variables:
        result: 244837814047284  # 0xDEADBEEF1234

  - name: bit_63_basic
    sv: |
      module Test;
        bit [62:0] a;
        longint result;
        initial begin
          a = 63'h7FFFFFFFFFFFFFF0;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 9223372036854775792  # 0x7FFFFFFFFFFFFFF0

  - name: bit_7_shift
    sv: |
      module Test;
        bit [6:0] a;
        int result;
        initial begin
          a = 7'b1010101;  // 85
          a = a << 2;      // Should mask to 7 bits
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 84  # (85 << 2) & 0x7F = 340 & 127 = 84

  - name: byte_type
    sv: |
      module Test;
        byte a;
        int result;
        initial begin
          a = -100;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -100

  - name: shortint_type
    sv: |
      module Test;
        shortint a;
        int result;
        initial begin
          a = -30000;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -30000

  - name: bit_2_basic
    sv: |
      module Test;
        bit [1:0] a;
        int result;
        initial begin
          a = 3;
          a = a + 1;  // Should wrap: 3 + 1 = 0 (mod 4)
          result = int'(a);
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: size_cast_truncation
    sv: |
      module Test;
        bit [3:0] val4;
        bit [7:0] val8;
        int result;
        initial begin
          val8 = 255;
          val4 = 4'(val8);  // Explicit size cast to truncate to 4 bits
          result = int'(val4);
        end
      endmodule
    expect:
      variables:
        result: 15  # 255 & 0xF = 15

  - name: size_cast_extension
    sv: |
      module Test;
        bit [3:0] val4;
        bit [7:0] val8;
        int result;
        initial begin
          val4 = 4'hF;
          val8 = 8'(val4);  // Extend to 8 bits
          result = int'(val8);
        end
      endmodule
    expect:
      variables:
        result: 15

  # Bit indexing tests
  - name: bit_index_constant
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10101010;  // 0xAA = 170
          result = a[1];    // Bit 1 is 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_index_zero
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10101010;
          result = a[0];    // Bit 0 is 0
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_index_high
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10000000;  // 128
          result = a[7];    // Bit 7 is 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_index_arithmetic
    sv: |
      module Test;
        bit [7:0] a;
        int sum;
        initial begin
          a = 8'b11001010;  // 0xCA
          sum = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7];
          // Bits: 0+1+0+1+0+0+1+1 = 4
        end
      endmodule
    expect:
      variables:
        sum: 4

  - name: bit_index_conditional
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 4'b1010;
          result = a[3] ? 100 : 200;  // Bit 3 is 1, so result = 100
        end
      endmodule
    expect:
      variables:
        result: 100

  # Range select tests
  - name: range_select_nibble
    sv: |
      module Test;
        bit [7:0] data;
        bit [3:0] high_nibble;
        int result;
        initial begin
          data = 8'hAB;
          high_nibble = data[7:4];
          result = high_nibble;
        end
      endmodule
    expect:
      variables:
        result: 10  # 0xA

  - name: range_select_low
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'hAB;
          result = data[3:0];
        end
      endmodule
    expect:
      variables:
        result: 11  # 0xB

  - name: range_select_middle
    sv: |
      module Test;
        bit [15:0] data;
        int result;
        initial begin
          data = 16'hABCD;
          result = data[11:4];  // Extract 0xBC
        end
      endmodule
    expect:
      variables:
        result: 188  # 0xBC

  - name: range_select_single_bit
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'b10101010;  // 0xAA: bits 7,5,3,1 are set
          result = data[5:5];  // Single bit at position 5 (which is 1)
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: range_select_full_width
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'hCA;
          result = data[7:0];  // Full width select
        end
      endmodule
    expect:
      variables:
        result: 202  # 0xCA
