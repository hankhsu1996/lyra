feature: wait_event
description: Tests for event control and sensitivity lists (LRM 9.4.2)

cases:
  - name: always_comb_runs_once_at_time_zero
    sv: |
      module Test;
        int a, b, c;
        initial begin
          a = 1;
          b = 2;
        end

        always_comb c = a + b;
      endmodule
    expect:
      variables:
        c: 3
      time: 0

  - name: always_comb_reacts_to_input_change
    sv: |
      module Test;
        int a, b, c;
        initial begin
          a = 1;
          b = 2;
          #5 a = 3;
        end

        always_comb c = a + b;
      endmodule
    expect:
      variables:
        c: 5
      time: 5

  - name: wait_until_change
    sv: |
      module Test;
        int a;
        initial begin
          @(a);
        end

        initial #5 a = 1;
      endmodule
    expect:
      variables:
        a: 1
      time: 5

  - name: wait_then_delay
    sv: |
      module Test;
        int a;
        initial begin
          @(a);
          #2;
        end

        initial #5 a = 1;
      endmodule
    expect:
      variables:
        a: 1
      time: 7

  - name: posedge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(posedge clk);
          seen = 1;
        end

        initial begin
          clk = 0;
          #5 clk = 1;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: negedge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(negedge clk);
          seen = 1;
        end

        initial begin
          clk = 1;
          #5 clk = 0;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: edge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(edge clk);
          seen = 1;
        end

        initial begin
          clk = 0;
          #5 clk = 1;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: always_ff_posedge
    sv: |
      module Test;
        int clk, q;
        initial clk = 0;

        always_ff @(posedge clk) q = 42;

        initial begin
          #2 clk = 1;
          #2 clk = 0;
          #2 clk = 1;
        end
      endmodule
    expect:
      variables:
        q: 42
      time: 6

  - name: always_latch_behavior
    sv: |
      module Test;
        int a, b, q;
        always_latch begin
          if (a > 0)
            q = a + b;
        end

        initial begin
          a = 1; b = 2;
          #5 a = 0;
        end
      endmodule
    expect:
      variables:
        q: 3
      time: 5

  - name: correct_posedge_count
    sv: |
      module Test;
        bit a;
        int count;

        always_ff @(posedge a) begin
          count = count + 1;
        end

        initial begin
          a = 0;
          #5 a = 1;
          #5 a = 0;
          #5 a = 1;
          #5 a = 0;
        end
      endmodule
    expect:
      variables:
        count: 2
      time: 20

  - name: any_change_string_trigger
    sv: |
      module Test;
        string s;
        int seen;
        initial begin
          @(s);
          seen = 1;
        end

        initial begin
          s = "abc";
          #3 s = "def";
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 3

  - name: posedge_or_negedge_trigger_first_edge
    description: |
      Test that @(posedge clk or negedge rst) triggers on posedge clk.
      Regression test for edge kind overwrite bug where wait_set_ key
      didn't include variable, causing last edge kind to overwrite previous.
    sv: |
      module Test;
        bit clk, rst;
        int seen;
        initial begin
          clk = 0;
          rst = 1;
          @(posedge clk or negedge rst);
          seen = 1;
        end

        initial #5 clk = 1;
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: posedge_or_negedge_trigger_second_edge
    description: |
      Test that @(posedge clk or negedge rst) triggers on negedge rst.
    sv: |
      module Test;
        bit clk, rst;
        int seen;
        initial begin
          clk = 0;
          rst = 1;
          @(posedge clk or negedge rst);
          seen = 1;
        end

        initial #5 rst = 0;
      endmodule
    expect:
      variables:
        seen: 1
      time: 5
