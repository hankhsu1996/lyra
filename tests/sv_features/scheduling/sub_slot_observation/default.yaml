feature: sub_slot_observation
description: |
  Tests for sub-slot observation byte-range narrowing. When always_comb reads
  a struct field or constant-indexed array element, the subscription should
  observe only that sub-range. Correctness is verified by checking that the
  always_comb re-evaluates when the observed element changes.

cases:
  - name: array_element_sensitivity
    description: always_comb reading arr[2] re-evaluates when arr[2] changes
    sv: |
      module Test;
        int arr[4];
        int result;

        always_comb result = arr[2];

        initial begin
          if (result != 0) $fatal(1, "expected 0 initially, got %0d", result);
          arr[0] = 10;
          #1;
          if (result != 0) $fatal(1, "arr[0] write changed result to %0d", result);
          arr[1] = 20;
          #1;
          if (result != 0) $fatal(1, "arr[1] write changed result to %0d", result);
          arr[2] = 42;
          #1;
          if (result != 42) $fatal(1, "expected 42, got %0d", result);
          arr[3] = 99;
          #1;
          if (result != 42) $fatal(1, "arr[3] write changed result to %0d", result);
          arr[2] = 100;
          #1;
          if (result != 100) $fatal(1, "expected 100, got %0d", result);
          $display("PASS");
        end
      endmodule
    expect:
      stdout: "PASS\n"

  - name: struct_field_sensitivity
    description: always_comb reading s.x and s.y tracks fields independently
    sv: |
      module Test;
        typedef struct { int x; int y; } point_t;
        point_t s;
        int out_x, out_y;

        always_comb out_x = s.x;
        always_comb out_y = s.y;

        initial begin
          s.x = 10;
          #1;
          if (out_x != 10) $fatal(1, "expected out_x=10, got %0d", out_x);
          if (out_y != 0) $fatal(1, "expected out_y=0, got %0d", out_y);
          s.y = 20;
          #1;
          if (out_x != 10) $fatal(1, "expected out_x=10, got %0d", out_x);
          if (out_y != 20) $fatal(1, "expected out_y=20, got %0d", out_y);
          s.x = 30;
          s.y = 40;
          #1;
          if (out_x != 30) $fatal(1, "expected out_x=30, got %0d", out_x);
          if (out_y != 40) $fatal(1, "expected out_y=40, got %0d", out_y);
          $display("PASS");
        end
      endmodule
    expect:
      stdout: "PASS\n"

  - name: blocking_no_wakeup_array
    description: |
      Blocking assign to arr[0] must not wake process observing arr[2].
      $display inside always_comb makes wakeups directly observable.
    sv: |
      module Test;
        int arr[4];
        int result;

        always_comb begin
          result = arr[2];
          $display("comb_eval arr[2]=%0d", arr[2]);
        end

        initial begin
          arr[2] = 42;
          #1;
          arr[0] = 99;
          #1;
          arr[2] = 55;
          #1;
          $display("PASS");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "comb_eval arr[2]=0"
          - "comb_eval arr[2]=42"
          - "comb_eval arr[2]=55"
          - "PASS"
        not_contains:
          - "comb_eval arr[2]=42\ncomb_eval arr[2]=42"

  - name: blocking_no_wakeup_struct
    description: |
      Blocking assign to s.y must not wake process observing s.x.
    sv: |
      module Test;
        typedef struct { int x; int y; int z; } triple_t;
        triple_t s;
        int result;

        always_comb begin
          result = s.x;
          $display("comb_eval s.x=%0d", s.x);
        end

        initial begin
          s.x = 10;
          #1;
          s.y = 20;
          #1;
          s.z = 30;
          #1;
          s.x = 40;
          #1;
          $display("PASS");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "comb_eval s.x=0"
          - "comb_eval s.x=10"
          - "comb_eval s.x=40"
          - "PASS"
        not_contains:
          - "comb_eval s.x=10\ncomb_eval s.x=10"

  - name: nba_no_wakeup_array
    description: |
      NBA to arr[0] must not wake process observing arr[2].
    sv: |
      module Test;
        int arr[4];
        int result;

        always_comb begin
          result = arr[2];
          $display("comb_eval arr[2]=%0d", arr[2]);
        end

        initial begin
          arr[2] <= 42;
          #1;
          arr[0] <= 99;
          #1;
          arr[2] <= 55;
          #1;
          $display("PASS");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "comb_eval arr[2]=0"
          - "comb_eval arr[2]=42"
          - "comb_eval arr[2]=55"
          - "PASS"
        not_contains:
          - "comb_eval arr[2]=42\ncomb_eval arr[2]=42"

  - name: nba_no_wakeup_struct
    description: |
      NBA to s.y must not wake process observing s.x.
    sv: |
      module Test;
        typedef struct { int x; int y; } pair_t;
        pair_t s;
        int result;

        always_comb begin
          result = s.x;
          $display("comb_eval s.x=%0d", s.x);
        end

        initial begin
          s.x <= 10;
          #1;
          s.y <= 20;
          #1;
          s.x <= 30;
          #1;
          $display("PASS");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "comb_eval s.x=0"
          - "comb_eval s.x=10"
          - "comb_eval s.x=30"
          - "PASS"
        not_contains:
          - "comb_eval s.x=10\ncomb_eval s.x=10"

  - name: nested_struct_array_blocking
    description: |
      Blocking assign to structs[0].x must not wake process observing structs[1].x.
      Tests multi-step projection chain (IndexProjection + FieldProjection).
    sv: |
      module Test;
        typedef struct { int x; int y; } pair_t;
        pair_t structs[2];
        int result;

        always_comb begin
          result = structs[1].x;
          $display("comb_eval structs[1].x=%0d", structs[1].x);
        end

        initial begin
          structs[1].x = 55;
          #1;
          structs[0].x = 99;
          #1;
          structs[0].y = 88;
          #1;
          structs[1].x = 77;
          #1;
          $display("PASS");
        end
      endmodule
    expect:
      stdout:
        contains:
          - "comb_eval structs[1].x=0"
          - "comb_eval structs[1].x=55"
          - "comb_eval structs[1].x=77"
          - "PASS"
        not_contains:
          - "comb_eval structs[1].x=55\ncomb_eval structs[1].x=55"

  - name: dynamic_index_falls_back_to_full_slot
    description: |
      Dynamic index write must fall back to full-slot dirty marking.
      Process observing arr[2] must still wake (conservative correctness).
    sv: |
      module Test;
        int arr[4];
        int result;
        int idx;

        always_comb result = arr[2];

        initial begin
          idx = 2;
          arr[idx] = 42;
          #1;
          if (result != 42) $fatal(1, "expected 42, got %0d", result);
          $display("PASS");
        end
      endmodule
    expect:
      stdout: "PASS\n"

  - name: mixed_array_and_scalar
    description: Process reads both arr[1] and a scalar, both trigger correctly
    sv: |
      module Test;
        int arr[3];
        int scalar;
        int result;

        always_comb result = arr[1] + scalar;

        initial begin
          arr[1] = 10;
          #1;
          if (result != 10) $fatal(1, "expected 10, got %0d", result);
          scalar = 5;
          #1;
          if (result != 15) $fatal(1, "expected 15, got %0d", result);
          arr[1] = 20;
          scalar = 3;
          #1;
          if (result != 23) $fatal(1, "expected 23, got %0d", result);
          $display("PASS");
        end
      endmodule
    expect:
      stdout: "PASS\n"
