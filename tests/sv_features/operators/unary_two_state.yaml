feature: unary_two_state
description: 2-state unary operators (+, -, !, ~, ++, --, reductions)

cases:
  - name: unary_plus
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 10;
          b = +a;
        end
      endmodule
    expect:
      variables:
        b: 10

  - name: unary_minus
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 10;
          b = -a;
        end
      endmodule
    expect:
      variables:
        b: -10

  - name: logical_not_nonzero
    sv: |
      module Test;
        int a;
        bit r;
        initial begin
          a = 10;
          r = !a;
        end
      endmodule
    expect:
      variables:
        r: 0

  - name: logical_not_zero
    sv: |
      module Test;
        int a;
        bit r;
        initial begin
          a = 0;
          r = !a;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: bitwise_not
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 10;
          b = ~a;
        end
      endmodule
    expect:
      variables:
        b: -11

  - name: compound_unary
    sv: |
      module Test;
        int a, b, c, d;
        initial begin
          a = 5;
          b = 3;
          c = -a + b * 2;
          d = -(a + b);
        end
      endmodule
    expect:
      variables:
        c: 1
        d: -8

  - name: pre_increment
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 5;
          b = ++a;
        end
      endmodule
    expect:
      variables:
        a: 6
        b: 6

  - name: post_increment
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 5;
          b = a++;
        end
      endmodule
    expect:
      variables:
        a: 6
        b: 5

  - name: pre_decrement
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 5;
          b = --a;
        end
      endmodule
    expect:
      variables:
        a: 4
        b: 4

  - name: post_decrement
    sv: |
      module Test;
        int a, b;
        initial begin
          a = 5;
          b = a--;
        end
      endmodule
    expect:
      variables:
        a: 4
        b: 5

  - name: nested_increment_decrement
    sv: |
      module Test;
        int a, b, c, d;
        initial begin
          a = 5;
          b = 10;
          c = ++a + b--;
          d = --a + ++b;
        end
      endmodule
    expect:
      variables:
        a: 5
        b: 10
        c: 16
        d: 15

  - name: logical_not_bit_types
    sv: |
      module Test;
        bit b0, b1;
        int zero, nonzero;
        bit r1, r2, r3, r4;
        initial begin
          b0 = 0;
          b1 = 1;
          zero = 0;
          nonzero = 42;
          r1 = !b0;
          r2 = !b1;
          r3 = !zero;
          r4 = !nonzero;
        end
      endmodule
    expect:
      variables:
        r1: 1
        r2: 0
        r3: 1
        r4: 0

  - name: mixed_types_unary
    sv: |
      module Test;
        bit b;
        int i;
        longint l;
        int result1, result2;
        initial begin
          b = 1;
          i = 100;
          l = 1000;
          result1 = -i + b;
          result2 = -(-i + l);
        end
      endmodule
    expect:
      variables:
        result1: -99
        result2: -900

  - name: reduction_and
    sv: |
      module Test;
        int a;
        bit r;
        initial begin
          a = 15;
          r = &a;
        end
      endmodule
    expect:
      variables:
        r: 0

  - name: reduction_nand
    sv: |
      module Test;
        int a;
        bit r;
        initial begin
          a = 15;
          r = ~&a;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: reduction_or
    sv: |
      module Test;
        int a;
        bit r;
        initial begin
          a = 15;
          r = |a;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: reduction_nor
    sv: |
      module Test;
        int b;
        bit r;
        initial begin
          b = 0;
          r = ~|b;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: reduction_xor
    sv: |
      module Test;
        int d;
        bit r;
        initial begin
          d = 11;
          r = ^d;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: reduction_xnor
    sv: |
      module Test;
        int c;
        bit r;
        initial begin
          c = 10;
          r = ~^c;
        end
      endmodule
    expect:
      variables:
        r: 1

  - name: reduction_or_wide_upper_bit
    description: Reduction OR where only upper bit (>8) is set - verifies no silent truncation
    sv: |
      module Test;
        bit [15:0] wide_val;
        bit result;
        initial begin
          wide_val = 16'h0100;  // Only bit 8 set (above 8-bit truncation point)
          result = |wide_val;   // Must be 1, not 0
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: reduction_and_wide_upper_bit
    description: Reduction AND where upper bits (>8) matter - all 16 bits must be 1
    sv: |
      module Test;
        bit [15:0] wide_val;
        bit result;
        initial begin
          wide_val = 16'h00FF;  // Only lower 8 bits set
          result = &wide_val;   // Must be 0, not 1 (upper bits are 0)
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: reduction_xor_wide_upper_bit
    description: Reduction XOR where only upper bit (>8) is set
    sv: |
      module Test;
        bit [15:0] wide_val;
        bit result;
        initial begin
          wide_val = 16'h0100;  // Only bit 8 set
          result = ^wide_val;   // Must be 1 (odd number of 1s)
        end
      endmodule
    expect:
      variables:
        result: 1
