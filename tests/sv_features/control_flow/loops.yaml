feature: loops
description: Tests for while, do-while, for, forever loops with break/continue

cases:
  # While loops
  - name: while_basic_counter
    sv: |
      module Test;
        int counter;
        int sum;
        initial begin
          counter = 0;
          sum = 0;
          while (counter < 5) begin
            sum = sum + counter;
            counter = counter + 1;
          end
        end
      endmodule
    expect:
      variables:
        counter: 5
        sum: 10

  - name: while_false_condition
    sv: |
      module Test;
        int x;
        initial begin
          x = 10;
          while (0) begin
            x = 20;
          end
        end
      endmodule
    expect:
      variables:
        x: 10

  - name: while_variable_condition
    sv: |
      module Test;
        int i;
        int result;
        initial begin
          i = 3;
          result = 0;
          while (i > 0) begin
            result = result + i;
            i = i - 1;
          end
        end
      endmodule
    expect:
      variables:
        i: 0
        result: 6

  - name: while_nested
    sv: |
      module Test;
        int i;
        int j;
        int sum;
        initial begin
          i = 0;
          sum = 0;
          while (i < 3) begin
            j = 0;
            while (j < 2) begin
              sum = sum + 1;
              j = j + 1;
            end
            i = i + 1;
          end
        end
      endmodule
    expect:
      variables:
        i: 3
        j: 2
        sum: 6

  # Do-while loops
  - name: do_while_basic_counter
    sv: |
      module Test;
        int counter;
        int sum;
        initial begin
          counter = 0;
          sum = 0;
          do begin
            sum = sum + counter;
            counter = counter + 1;
          end while (counter < 5);
        end
      endmodule
    expect:
      variables:
        counter: 5
        sum: 10

  - name: do_while_false_condition
    sv: |
      module Test;
        int x;
        initial begin
          x = 10;
          do begin
            x = 20;
          end while (0);
        end
      endmodule
    expect:
      variables:
        x: 20

  - name: do_while_variable_condition
    sv: |
      module Test;
        int i;
        int result;
        initial begin
          i = 3;
          result = 0;
          do begin
            result = result + i;
            i = i - 1;
          end while (i > 0);
        end
      endmodule
    expect:
      variables:
        i: 0
        result: 6

  - name: do_while_nested
    sv: |
      module Test;
        int i;
        int j;
        int sum;
        initial begin
          i = 0;
          sum = 0;
          do begin
            j = 0;
            do begin
              sum = sum + 1;
              j = j + 1;
            end while (j < 2);
            i = i + 1;
          end while (i < 3);
        end
      endmodule
    expect:
      variables:
        i: 3
        j: 2
        sum: 6

  # For loops
  - name: for_basic_counter
    sv: |
      module Test;
        int i;
        int sum;
        initial begin
          sum = 0;
          for (i = 0; i < 5; i = i + 1) begin
            sum = sum + i;
          end
        end
      endmodule
    expect:
      variables:
        i: 5
        sum: 10

  - name: for_with_loop_var_declaration
    sv: |
      module Test;
        int sum;
        initial begin
          sum = 0;
          for (int i = 0; i < 5; i = i + 1) begin
            sum = sum + i;
          end
        end
      endmodule
    expect:
      variables:
        sum: 10

  - name: for_with_multiple_initializers
    sv: |
      module Test;
        int i, j, sum;
        initial begin
          sum = 0;
          for (i = 0, j = 3; i < 3; i = i + 1, j = j + 1) begin
            sum = sum + i + j;
          end
        end
      endmodule
    expect:
      variables:
        sum: 15

  - name: for_without_initializer
    sv: |
      module Test;
        int i;
        int sum;
        initial begin
          i = 1;
          sum = 0;
          for (; i <= 3; i = i + 1) begin
            sum = sum + i;
          end
        end
      endmodule
    expect:
      variables:
        i: 4
        sum: 6

  - name: for_without_step
    sv: |
      module Test;
        int i;
        int x;
        initial begin
          x = 0;
          for (i = 0; i < 1;) begin
            x = x + 1;
            i = i + 1;
          end
        end
      endmodule
    expect:
      variables:
        x: 1
        i: 1

  - name: for_nested
    sv: |
      module Test;
        int i, j, product;
        initial begin
          product = 1;
          for (i = 1; i <= 2; i = i + 1) begin
            for (j = 1; j <= 2; j = j + 1) begin
              product = product * j;
            end
          end
        end
      endmodule
    expect:
      variables:
        product: 4

  # Forever loop
  - name: forever_with_finish
    sv: |
      module Test;
        int counter;
        initial begin
          counter = 0;
          forever begin
            counter = counter + 1;
            if (counter >= 5) $finish;
          end
        end
      endmodule
    expect:
      variables:
        counter: 5

  - name: for_without_condition
    sv: |
      module Test;
        int i;
        initial begin
          for (i = 0; ; i = i + 1) begin
            if (i == 3) $finish;
          end
        end
      endmodule
    expect:
      variables:
        i: 3

  # Break
  - name: break_in_while
    sv: |
      module Test;
        int i;
        initial begin
          i = 0;
          while (1) begin
            if (i == 3) break;
            i = i + 1;
          end
        end
      endmodule
    expect:
      variables:
        i: 3

  - name: break_in_do_while
    sv: |
      module Test;
        int x;
        initial begin
          x = 0;
          do begin
            x = x + 1;
            if (x == 2) break;
          end while (1);
        end
      endmodule
    expect:
      variables:
        x: 2

  - name: break_in_for
    sv: |
      module Test;
        int i;
        initial begin
          for (i = 0; i < 10; i = i + 1) begin
            if (i == 4) break;
          end
        end
      endmodule
    expect:
      variables:
        i: 4

  - name: break_inner_loop
    sv: |
      module Test;
        int i, j, count;
        initial begin
          count = 0;
          for (i = 0; i < 2; i = i + 1) begin
            j = 0;
            while (j < 3) begin
              if (j == 1) break;
              count = count + 1;
              j = j + 1;
            end
          end
        end
      endmodule
    expect:
      variables:
        count: 2

  # Continue
  - name: continue_in_while
    sv: |
      module Test;
        int i, sum;
        initial begin
          i = 0;
          sum = 0;
          while (i < 5) begin
            i = i + 1;
            if (i == 2)
              continue;
            if (i == 4)
              continue;
            sum = sum + i;
          end
        end
      endmodule
    expect:
      variables:
        sum: 9

  - name: continue_in_do_while
    sv: |
      module Test;
        int i, sum;
        initial begin
          i = 0;
          sum = 0;
          do begin
            i = i + 1;
            if (i == 2)
              continue;
            if (i == 4)
              continue;
            sum = sum + i;
          end while (i < 5);
        end
      endmodule
    expect:
      variables:
        sum: 9

  # Repeat loops
  - name: repeat_basic_counter
    sv: |
      module Test;
        int counter;
        initial begin
          counter = 0;
          repeat (5) begin
            counter = counter + 1;
          end
        end
      endmodule
    expect:
      variables:
        counter: 5

  - name: repeat_zero_count
    sv: |
      module Test;
        int x;
        initial begin
          x = 10;
          repeat (0) begin
            x = 20;
          end
        end
      endmodule
    expect:
      variables:
        x: 10

  - name: repeat_variable_count
    sv: |
      module Test;
        int n;
        int sum;
        initial begin
          n = 3;
          sum = 0;
          repeat (n) begin
            sum = sum + 1;
          end
        end
      endmodule
    expect:
      variables:
        sum: 3

  - name: repeat_nested
    sv: |
      module Test;
        int count;
        initial begin
          count = 0;
          repeat (3) begin
            repeat (2) begin
              count = count + 1;
            end
          end
        end
      endmodule
    expect:
      variables:
        count: 6

  - name: repeat_with_break
    sv: |
      module Test;
        int i;
        initial begin
          i = 0;
          repeat (10) begin
            if (i == 3) break;
            i = i + 1;
          end
        end
      endmodule
    expect:
      variables:
        i: 3

  - name: repeat_with_continue
    sv: |
      module Test;
        int i;
        int sum;
        initial begin
          i = 0;
          sum = 0;
          repeat (5) begin
            i = i + 1;
            if (i == 2 || i == 4)
              continue;
            sum = sum + i;
          end
        end
      endmodule
    expect:
      variables:
        sum: 9

  - name: repeat_with_event_control
    description: |
      Test that repeat loop counter survives across event control suspension.
      This verifies ProcessFrame persistence (the coroutine frame fix).
    sv: |
      module Test;
        logic clk = 0;
        int counter = 0;
        always #5 clk = ~clk;
        initial begin
          repeat (3) @(posedge clk) begin
            counter = counter + 1;
          end
          $finish;
        end
      endmodule
    expect:
      variables:
        counter: 3

  - name: repeat_with_delay
    description: |
      Test that repeat loop counter survives across delay suspension.
    sv: |
      module Test;
        int counter = 0;
        initial begin
          repeat (4) begin
            #10;
            counter = counter + 1;
          end
          $finish;
        end
      endmodule
    expect:
      variables:
        counter: 4

  # Compound triggers - test centralized frame ownership
  - name: compound_trigger_second_fires_first
    description: |
      Test that @(a or b) preserves frame when second trigger fires first.
      This was broken before centralized frame ownership - only the first
      trigger got the frame, so if the second trigger fired first, the
      process would resume with an empty frame.
    sv: |
      module Test;
        bit clk = 0, rst = 1;
        int result = 0;
        initial begin
          int temp = 42;
          @(posedge clk or negedge rst);
          result = temp;
          $finish;
        end
        initial #5 rst = 0;  // negedge rst fires first
      endmodule
    expect:
      variables:
        result: 42

  - name: compound_trigger_first_fires
    description: |
      Test that @(a or b) also works when first trigger fires.
    sv: |
      module Test;
        bit clk = 0, rst = 1;
        int result = 0;
        initial begin
          int temp = 100;
          @(posedge clk or negedge rst);
          result = temp;
          $finish;
        end
        initial #5 clk = 1;  // posedge clk fires first
      endmodule
    expect:
      variables:
        result: 100

  - name: compound_trigger_three_triggers
    description: |
      Test compound trigger with three variables (@(a or b or c)).
      Verifies frame preservation works with more than two triggers.
    sv: |
      module Test;
        bit a = 0, b = 0, c = 0;
        int result = 0;
        initial begin
          int temp = 77;
          @(posedge a or posedge b or posedge c);
          result = temp;
          $finish;
        end
        initial #5 b = 1;  // middle trigger fires
      endmodule
    expect:
      variables:
        result: 77

  - name: compound_trigger_same_time_slot
    description: |
      Test compound trigger when multiple signals change in same time slot.
      Only one should trigger the process (deduplication).
    sv: |
      module Test;
        bit clk = 0, rst = 0;
        int count = 0;
        initial begin
          int temp = 55;
          @(posedge clk or posedge rst);
          count = temp;
          $finish;
        end
        initial begin
          #5;
          clk = 1;  // Both change at time 5
          rst = 1;
        end
      endmodule
    expect:
      variables:
        count: 55
