feature: edge trigger on sub-expressions
description: >
  Edge triggers (@posedge/@negedge) on constant bit/element-selects on packed
  types, packed struct fields (any width), constant-index unpacked array elements
  (any width), unpacked struct fields (any width), and constant range/part-
  selects on packed types. For multi-bit sub-expressions, edge behavior samples
  the expression LSB (expr[0]). Level-sensitive waits observe the full
  expression.

cases:
  - name: posedge_bit3
    description: "@(posedge bus[3]) wakes when bit 3 transitions 0->1"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger
    description: "@(posedge bus[3]) must NOT wake when only bit 0 changes"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3]);
          result = 1;
          $finish;
        end
        initial begin
          #5 bus = 8'b0000_0001;
          #5 bus = 8'b0000_1000;
        end
      endmodule
    expect:
      variables:
        result: 1
      stdout:
        not_contains:
          - "time 5"

  - name: negedge_bit
    description: "@(negedge bus[3]) detects 1->0 on bit 3"
    sv: |
      module Test;
        logic [7:0] bus = 8'b0000_1000;
        int result = 0;
        initial begin
          @(negedge bus[3]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_0000;
      endmodule
    expect:
      variables:
        result: 1

  - name: high_bit
    description: "@(posedge bus[11]) on a 16-bit value (byte_offset=1, bit_index=3)"
    sv: |
      module Test;
        logic [15:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[11]);
          result = 1;
          $finish;
        end
        initial #5 bus = 16'h0800;
      endmodule
    expect:
      variables:
        result: 1

  - name: nonzero_based_range
    description: "@(posedge bus[12]) on logic [15:8] maps to correct storage bit"
    sv: |
      module Test;
        logic [15:8] bus = 8'h00;
        int result = 0;
        initial begin
          @(posedge bus[12]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'h10;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_root_unchanged
    description: "@(posedge clk) on a plain scalar still works (regression control)"
    sv: |
      module Test;
        bit clk = 0;
        int result = 0;
        initial begin
          @(posedge clk);
          result = 42;
          $finish;
        end
        initial #5 clk = 1;
      endmodule
    expect:
      variables:
        result: 42

  - name: both_edges_bit_select
    description: "@(edge bus[3]) triggers on both 0->1 and 1->0"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int count = 0;
        initial begin
          @(edge bus[3]);
          count = count + 1;
          @(edge bus[3]);
          count = count + 1;
          $finish;
        end
        initial begin
          #5 bus = 8'b0000_1000;
          #5 bus = 8'b0000_0000;
        end
      endmodule
    expect:
      variables:
        count: 2

  - name: posedge_packed_struct_field
    description: "@(posedge s.a) on a single-bit packed struct field"
    sv: |
      module Test;
        typedef struct packed { logic a; logic [6:0] b; } pkt_t;
        pkt_t s = 8'h00;
        int result = 0;
        initial begin
          @(posedge s.a);
          result = 1;
          $finish;
        end
        initial #5 s = 8'h80;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_struct_field
    description: "@(posedge s.a) must NOT wake when only s.b changes"
    sv: |
      module Test;
        typedef struct packed { logic a; logic [6:0] b; } pkt_t;
        pkt_t s = 8'h00;
        int result = 0;
        initial begin
          @(posedge s.a);
          result = 1;
          $finish;
        end
        initial begin
          #5 s = 8'h01;
          #5 s = 8'h80;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_indexed_part_select_up
    description: "@(posedge bus[3 +: 1]) wakes on bit 3 transition"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3 +: 1]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_indexed_part_select_down
    description: "@(posedge bus[3 -: 1]) wakes on bit 3 transition"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3 -: 1]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_range_select_single
    description: "@(posedge bus[3:3]) wakes on bit 3 transition"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3:3]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: event_list_with_struct_field_edge
    description: "@(posedge clk or negedge s.a) verifies event-list validation"
    sv: |
      module Test;
        typedef struct packed { logic a; logic [6:0] b; } pkt_t;
        bit clk = 0;
        pkt_t s = 8'h80;
        int result = 0;
        initial begin
          @(posedge clk or negedge s.a);
          result = 1;
          $finish;
        end
        initial #5 s = 8'h00;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_range_select_single_ascending_base
    description: "@(posedge bus[3:3]) on ascending [0:7] maps to correct storage bit"
    sv: |
      module Test;
        logic [0:7] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3:3]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0001_0000;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_unpacked_array_element
    description: "@(posedge arr[0]) on unpacked array of 1-bit elements"
    sv: |
      module Test;
        logic arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[0]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_unpacked_array
    description: "@(posedge arr[0]) must NOT wake when arr[1] changes"
    sv: |
      module Test;
        logic arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[0]);
          result = 1;
          $finish;
        end
        initial begin
          #5 arr[1] = 1;
          #5 arr[0] = 1;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_unpacked_array_nonzero_index
    description: "@(posedge arr[2]) triggers on element 2"
    sv: |
      module Test;
        logic arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[2]);
          result = 1;
          $finish;
        end
        initial #5 arr[2] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_unpacked_array_descending_range
    description: "@(posedge arr[0]) on descending [3:0] range"
    sv: |
      module Test;
        logic arr [3:0];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[0]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_unpacked_struct_field
    description: "@(posedge s.flag) on single-bit unpacked struct field"
    sv: |
      module Test;
        typedef struct { logic flag; logic [7:0] data; } s_t;
        s_t s;
        int result = 0;
        initial begin
          s.flag = 0;
          s.data = 0;
          @(posedge s.flag);
          result = 1;
          $finish;
        end
        initial #5 s.flag = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_unpacked_struct
    description: "@(posedge s.flag) must NOT wake when s.data changes"
    sv: |
      module Test;
        typedef struct { logic flag; logic [7:0] data; } s_t;
        s_t s;
        int result = 0;
        initial begin
          s.flag = 0;
          s.data = 0;
          @(posedge s.flag);
          result = 1;
          $finish;
        end
        initial begin
          #5 s.data = 8'hFF;
          #5 s.flag = 1;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: event_list_unpacked
    description: "@(posedge clk or negedge arr[0]) in event list"
    sv: |
      module Test;
        bit clk = 0;
        logic arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 1;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge clk or negedge arr[0]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 0;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_packed_element
    description: "@(posedge bus[1]) on packed array with multi-bit elements wakes on element LSB 0->1"
    sv: |
      module Test;
        logic [1:0][7:0] bus = 16'h0000;
        int result = 0;
        initial begin
          @(posedge bus[1]);
          result = 1;
          $finish;
        end
        initial #5 bus[1] = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_packed_struct_field
    description: "@(posedge s.b) on multi-bit packed struct field wakes on field LSB 0->1"
    sv: |
      module Test;
        typedef struct packed { logic a; logic [6:0] b; } pkt_t;
        pkt_t s = 8'h00;
        int result = 0;
        initial begin
          @(posedge s.b);
          result = 1;
          $finish;
        end
        initial #5 s = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_range_select
    description: "@(posedge bus[7:4]) wakes when LSB (bit 4) transitions 0->1"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[7:4]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'h10;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_multibit_range
    description: "@(posedge bus[7:4]) must NOT wake when only bus[3:0] changes"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[7:4]);
          result = 1;
          $finish;
        end
        initial begin
          #5 bus = 8'h0F;
          #5 bus = 8'h10;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_part_select_ascending
    description: "@(posedge bus[3 +: 4]) wakes when LSB (bit 3) transitions 0->1"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[3 +: 4]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'h08;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_part_select_descending
    description: "@(posedge bus[6 -: 4]) wakes when LSB (bit 3) transitions 0->1"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          @(posedge bus[6 -: 4]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'h08;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_edge_multibit_packed_field
    description: "@(posedge clk or negedge s.b) with multi-bit packed field in event list"
    sv: |
      module Test;
        typedef struct packed { logic a; logic [6:0] b; } pkt_t;
        bit clk = 0;
        pkt_t s = 8'h01;
        int result = 0;
        initial begin
          @(posedge clk or negedge s.b);
          result = 1;
          $finish;
        end
        initial #5 s = 8'h00;
      endmodule
    expect:
      variables:
        result: 1

  - name: level_sensitive_multibit_unpacked_member_not_bit0_only
    description: "@(s.data) level-sensitive must wake on non-bit0 changes (NOT narrowed to expr[0])"
    sv: |
      module Test;
        typedef struct { logic [7:0] data; logic flag; } s_t;
        s_t s;
        int result = 0;
        initial begin
          s.data = 0;
          s.flag = 0;
          @(s.data);
          result = 1;
          $finish;
        end
        initial #5 s.data = 8'h80;
      endmodule
    expect:
      variables:
        result: 1

  - name: level_sensitive_multibit_unpacked_element_not_bit0_only
    description: "@(arr[0]) level-sensitive must wake on non-bit0 changes (NOT narrowed to expr[0])"
    sv: |
      module Test;
        logic [7:0] arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          @(arr[0]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 8'h80;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_unpacked_array_element
    description: "@(posedge arr[0]) on multi-bit unpacked array element wakes on LSB 0->1"
    sv: |
      module Test;
        logic [7:0] arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[0]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_multibit_unpacked_struct_field
    description: "@(posedge s.data) on multi-bit unpacked struct field wakes on LSB 0->1"
    sv: |
      module Test;
        typedef struct { logic [7:0] data; logic flag; } s_t;
        s_t s;
        int result = 0;
        initial begin
          s.data = 0;
          s.flag = 0;
          @(posedge s.data);
          result = 1;
          $finish;
        end
        initial #5 s.data = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_multibit_unpacked_array
    description: "@(posedge arr[0]) must NOT wake when only non-LSB bits change, then LSB change wakes"
    sv: |
      module Test;
        logic [7:0] arr [0:3];
        int result = 0;
        initial begin
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          arr[3] = 0;
          @(posedge arr[0]);
          result = 1;
          $finish;
        end
        initial begin
          #5 arr[0] = 8'h80;
          #5 arr[0] = 8'h81;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger_multibit_unpacked_struct
    description: "@(posedge s.data) must NOT wake when only non-LSB bits change, then LSB change wakes"
    sv: |
      module Test;
        typedef struct { logic [7:0] data; logic flag; } s_t;
        s_t s;
        int result = 0;
        initial begin
          s.data = 0;
          s.flag = 0;
          @(posedge s.data);
          result = 1;
          $finish;
        end
        initial begin
          #5 s.data = 8'hFE;
          #5 s.data = 8'hFF;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_unpacked_array_negative_index
    description: "@(posedge arr[-1]) on fixed array with negative bound accepted and works"
    sv: |
      module Test;
        logic [7:0] arr [-1:2];
        int result = 0;
        initial begin
          arr[-1] = 0;
          arr[0] = 0;
          arr[1] = 0;
          arr[2] = 0;
          @(posedge arr[-1]);
          result = 1;
          $finish;
        end
        initial #5 arr[-1] = 8'h01;
      endmodule
    expect:
      variables:
        result: 1
