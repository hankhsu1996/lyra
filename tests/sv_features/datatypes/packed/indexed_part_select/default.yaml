feature: indexed_part_select
description: Variable-width indexed part-select expressions (a[i+:width], a[i-:width])

cases:
  - name: ascending_constant_index
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[8+:8];  // Extract byte at position 8 = 0xBE
        end
      endmodule
    expect:
      variables:
        result: 190

  - name: ascending_variable_index
    sv: |
      module Test;
        bit [31:0] data;
        int i;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          i = 16;
          result = data[i+:8];  // Extract byte at position 16 = 0xAD
        end
      endmodule
    expect:
      variables:
        result: 173

  - name: descending_constant_index
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[15-:8];  // Extract bits [15:8] = 0xBE
        end
      endmodule
    expect:
      variables:
        result: 190

  - name: descending_variable_index
    sv: |
      module Test;
        bit [31:0] data;
        int i;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          i = 23;
          result = data[i-:8];  // Extract bits [23:16] = 0xAD
        end
      endmodule
    expect:
      variables:
        result: 173

  - name: loop_byte_extraction
    sv: |
      module Test;
        bit [31:0] data;
        int sum;
        initial begin
          data = 32'h01020304;
          sum = 0;
          for (int i = 0; i < 4; i = i + 1) begin
            sum = sum + data[i*8+:8];
          end
        end
      endmodule
    expect:
      variables:
        sum: 10

  - name: nibble_select
    sv: |
      module Test;
        bit [15:0] data;
        int i;
        int result;
        initial begin
          data = 16'hABCD;
          i = 8;
          result = data[i+:4];  // Extract nibble at bit 8 = 0xB
        end
      endmodule
    expect:
      variables:
        result: 11

  # Critical: width=1 single-bit extraction
  - name: width1_ascending
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[12+:1];  // Extract single bit at position 12 = 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: width1_descending
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[12-:1];  // Extract single bit at position 12 = 1
        end
      endmodule
    expect:
      variables:
        result: 1

  # Critical: non-zero-based vectors
  - name: nonzero_based_ascending
    sv: |
      module Test;
        bit [63:32] data;  // Non-zero-based: indices 32-63
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[40+:8];  // Extract byte at index 40 = 0xBE = 190
        end
      endmodule
    expect:
      variables:
        result: 190

  - name: nonzero_based_descending
    sv: |
      module Test;
        bit [63:32] data;  // Non-zero-based: indices 32-63
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[47-:8];  // Extract bits [47:40] = 0xBE = 190
        end
      endmodule
    expect:
      variables:
        result: 190

  # Boundary tests
  - name: boundary_low
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[0+:8];  // Extract lowest byte = 0xEF = 239
        end
      endmodule
    expect:
      variables:
        result: 239

  - name: boundary_high
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[24+:8];  // Extract highest byte = 0xDE = 222
        end
      endmodule
    expect:
      variables:
        result: 222

  # Equivalence: indexed part-select should match constant slice
  - name: equivalence_with_slice
    sv: |
      module Test;
        bit [31:0] data;
        int slice_result;
        int partsel_result;
        initial begin
          data = 32'hDEADBEEF;
          slice_result = data[15:8];     // Constant slice = 0xBE = 190
          partsel_result = data[8+:8];   // Part-select = 0xBE = 190
        end
      endmodule
    expect:
      variables:
        slice_result: 190
        partsel_result: 190

  # Width 16 test (larger slice)
  - name: width16_select
    sv: |
      module Test;
        bit [31:0] data;
        int result;
        initial begin
          data = 32'hDEADBEEF;
          result = data[8+:16];  // Extract bits [23:8] = 0xADBE = 44478
        end
      endmodule
    expect:
      variables:
        result: 44478

  # 2D array indexed part-select
  - name: indexed_partsel_on_2d
    sv: |
      module Test;
        bit [1:0][7:0] data;  // 2 elements of 8 bits each
        int i;
        int result;
        initial begin
          data[0] = 8'hAB;
          data[1] = 8'hCD;
          i = 4;
          result = data[1][i+:4];  // Extract high nibble of data[1] = 0xC = 12
        end
      endmodule
    expect:
      variables:
        result: 12

  # Write tests
  - name: write_ascending_constant
    sv: |
      module Test;
        bit [31:0] data;
        initial begin
          data = 32'h00000000;
          data[8+:8] = 8'hFF;  // Set byte at position 8
        end
      endmodule
    expect:
      variables:
        data: "32'hFF00"

  - name: write_ascending_variable
    sv: |
      module Test;
        bit [31:0] data;
        int i;
        initial begin
          data = 32'h00000000;
          i = 4;
          data[i+:8] = 8'hFF;  // Set bits [11:4] to 0xFF
        end
      endmodule
    expect:
      variables:
        data: "32'hFF0"

  - name: write_descending_constant
    sv: |
      module Test;
        bit [31:0] data;
        initial begin
          data = 32'h00000000;
          data[15-:8] = 8'hAB;  // Set bits [15:8] to 0xAB
        end
      endmodule
    expect:
      variables:
        data: "32'hAB00"

  - name: write_descending_variable
    sv: |
      module Test;
        bit [31:0] data;
        int i;
        initial begin
          data = 32'h00000000;
          i = 23;
          data[i-:8] = 8'hCD;  // Set bits [23:16] to 0xCD
        end
      endmodule
    expect:
      variables:
        data: "32'hCD0000"

  - name: write_nibble
    sv: |
      module Test;
        bit [15:0] data;
        initial begin
          data = 16'h0000;
          data[4+:4] = 4'hA;   // Set second nibble
          data[12+:4] = 4'hB;  // Set fourth nibble
        end
      endmodule
    expect:
      variables:
        data: "16'hB0A0"

  - name: write_loop
    sv: |
      module Test;
        bit [31:0] data;
        initial begin
          data = 32'h00000000;
          for (int i = 0; i < 4; i = i + 1) begin
            data[i*8+:8] = i + 1;  // Set bytes to 1, 2, 3, 4
          end
        end
      endmodule
    expect:
      variables:
        data: "32'h04030201"

  - name: write_nonzero_based
    sv: |
      module Test;
        bit [63:32] data;  // Non-zero-based: indices 32-63
        initial begin
          data = 32'h00000000;
          data[40+:8] = 8'hAB;  // Set byte at index 40
        end
      endmodule
    expect:
      variables:
        data: "32'hAB00"

  # Function scope write tests
  - name: write_in_function_constant_index
    description: Write to indexed part-select with constant index in function
    sv: |
      module Test;
        int result;

        function automatic logic [15:0] set_nibble();
          logic [15:0] data;
          data = 16'h0000;
          data[4+:4] = 4'hA;  // Set second nibble
          return data;
        endfunction

        initial begin
          result = set_nibble();
        end
      endmodule
    expect:
      variables:
        result: 0x00A0

  - name: write_in_function_variable_index
    description: Write to indexed part-select with variable index in function (like prim_cipher_pkg.sv)
    sv: |
      module Test;
        int result;

        function automatic logic [15:0] write_at_idx(input int idx, input logic [3:0] val);
          logic [15:0] data;
          data = 16'h0000;
          data[idx+:4] = val;  // Dynamic indexed part-select write
          return data;
        endfunction

        initial begin
          result = write_at_idx(8, 4'hB);  // Set bits [11:8] to 0xB
        end
      endmodule
    expect:
      variables:
        result: 0x0B00

  - name: write_bit_in_function
    description: Write to single bit select in function
    sv: |
      module Test;
        int result;

        function automatic logic [7:0] set_bit(input int idx);
          logic [7:0] data;
          data = 8'h00;
          data[idx] = 1'b1;  // Set single bit
          return data;
        endfunction

        initial begin
          result = set_bit(3);
        end
      endmodule
    expect:
      variables:
        result: 0x08

  - name: write_range_in_function
    description: Write to constant range select in function
    sv: |
      module Test;
        int result;

        function automatic logic [15:0] set_range();
          logic [15:0] data;
          data = 16'h0000;
          data[11:8] = 4'hC;  // Set bits [11:8]
          return data;
        endfunction

        initial begin
          result = set_range();
        end
      endmodule
    expect:
      variables:
        result: 0x0C00

  - name: write_loop_in_function
    description: Loop writing to indexed part-select in function (common cipher pattern)
    sv: |
      module Test;
        int result;

        function automatic logic [31:0] build_word();
          logic [31:0] data;
          data = 32'h00000000;
          for (int i = 0; i < 4; i = i + 1) begin
            data[i*8+:8] = i + 1;  // Set bytes to 1, 2, 3, 4
          end
          return data;
        endfunction

        initial begin
          result = build_word();
        end
      endmodule
    expect:
      variables:
        result: 0x04030201
