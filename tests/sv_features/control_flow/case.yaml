feature: case_statements
description: Tests for case statements (case, casez, casex - no case inside)

cases:
  - name: case_basic_match
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 2;
          result = 0;
          case (x)
            1: result = 10;
            2: result = 20;
            3: result = 30;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 20

  - name: case_no_match_no_default
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 5;
          result = 100;
          case (x)
            1: result = 10;
            2: result = 20;
            3: result = 30;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 100

  - name: case_default
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 5;
          result = 0;
          case (x)
            1: result = 10;
            2: result = 20;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 99

  - name: case_multiple_values
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 3;
          result = 0;
          case (x)
            1, 2: result = 10;
            3, 4: result = 20;
            5, 6: result = 30;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 20

  - name: case_first_match_wins
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 2;
          result = 0;
          case (x)
            2: result = 10;
            2: result = 20;
            2: result = 30;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 10

  - name: case_variable_condition
    sv: |
      module Test;
        int selector;
        int a, b, c;
        int result;
        initial begin
          selector = 2;
          a = 10;
          b = 20;
          c = 30;
          result = 0;
          case (selector)
            1: result = a;
            2: result = b;
            3: result = c;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 20

  - name: case_constant_expression
    sv: |
      module Test;
        int encode;
        int result;
        initial begin
          encode = 2;
          result = 0;
          case (1)
            encode == 1: result = 1;
            encode == 2: result = 2;
            encode == 3: result = 3;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 2

  - name: case_nested
    sv: |
      module Test;
        int x;
        int y;
        int result;
        initial begin
          x = 1;
          y = 2;
          result = 0;
          case (x)
            1: begin
              case (y)
                1: result = 11;
                2: result = 12;
                default: result = 19;
              endcase
            end
            2: begin
              case (y)
                1: result = 21;
                2: result = 22;
                default: result = 29;
              endcase
            end
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 12

  # casez tests - ? and z are wildcards
  # Using int type since logic [3:0] is not yet supported
  - name: casez_basic_wildcard
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 10;  // 0b1010
          result = 0;
          casez (x)
            32'b1???????????????????????????????: result = 1;  // MSB is 0
            32'b0000000000000000000000000000????: result = 2;  // Match low 4 bits as 1xxx
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 2

  - name: casez_simple
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 5;  // binary: 0101
          result = 0;
          casez (x)
            32'd5: result = 1;  // exact match
            32'd10: result = 2;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: casez_wildcard_match
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 7;  // binary: 0111
          result = 0;
          casez (x)
            32'b00000000000000000000000000000???: result = 1;  // matches 0-7
            32'b0000000000000000000000000000????: result = 2;  // matches 0-15
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: casez_no_match
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 100;
          result = 0;
          casez (x)
            32'd1: result = 1;
            32'd2: result = 2;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 99

  - name: casez_first_match_wins
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 5;
          result = 0;
          casez (x)
            32'b00000000000000000000000000000???: result = 1;  // matches 0-7
            32'd5: result = 2;  // exact match for 5
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1

  # casex tests - ?, x, and z are wildcards
  - name: casex_basic
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 5;  // binary: 0101
          result = 0;
          casex (x)
            32'b00000000000000000000000000000xxx: result = 1;  // matches 0-7
            32'd10: result = 2;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: casez_nested
    sv: |
      module Test;
        int x;
        int y;
        int result;
        initial begin
          x = 5;  // binary: 0101
          y = 4;  // binary: 0100
          result = 0;
          casez (x)
            32'b00000000000000000000000000000???: begin
              // x matches 0-7 (low 3 bits wildcarded)
              casez (y)
                32'b00000000000000000000000000000100: result = 10;  // y = 4 exactly
                default: result = 19;
              endcase
            end
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 10

  # Tests for casez/casex with known values (no wildcards in literals)
  # These verify the statement infrastructure works correctly
  - name: casez_known_values_match
    description: casez with all-known values behaves like regular case
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 42;
          result = 0;
          casez (x)
            32'd10: result = 1;
            32'd42: result = 2;
            32'd100: result = 3;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 2

  - name: casex_known_values_match
    description: casex with all-known values behaves like regular case
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 7;
          result = 0;
          casex (x)
            32'd5: result = 1;
            32'd6: result = 2;
            32'd7: result = 3;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 3

  - name: casez_known_values_default
    description: casez falls through to default when no match
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 999;
          result = 0;
          casez (x)
            32'd1: result = 1;
            32'd2: result = 2;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 99

  - name: casex_known_values_default
    description: casex falls through to default when no match
    sv: |
      module Test;
        int x;
        int result;
        initial begin
          x = 888;
          result = 0;
          casex (x)
            32'd1: result = 1;
            32'd2: result = 2;
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 99

  # Tests for 2-state to 4-state implicit conversion
  # When casez/casex selector is 2-state (int) but patterns are 4-state (logic),
  # slang inserts an implicit conversion. This tests that the conversion works
  # correctly and wildcard matching still functions.
  - name: casez_2state_selector_4state_pattern
    description: 2-state int selector implicitly converts to 4-state for wildcard match
    sv: |
      module Test;
        int x;  // 2-state type
        int result;
        initial begin
          x = 11;  // binary: 1011, ends with 1
          result = 0;
          casez (x)
            32'b???1: result = 1;  // 4-state pattern with wildcards
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: casez_2state_selector_no_match
    description: 2-state int selector with 4-state pattern, no wildcard match
    sv: |
      module Test;
        int x;  // 2-state type
        int result;
        initial begin
          x = 10;  // binary: 1010, ends with 0
          result = 0;
          casez (x)
            32'b???1: result = 1;  // doesn't match - LSB is 0
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 99

  - name: casex_2state_selector_4state_pattern
    description: 2-state int selector implicitly converts to 4-state for casex wildcard
    sv: |
      module Test;
        int x;  // 2-state type
        int result;
        initial begin
          x = 15;  // binary: 1111
          result = 0;
          casex (x)
            32'bxxxx: result = 1;  // x wildcards match any value
            default: result = 99;
          endcase
        end
      endmodule
    expect:
      variables:
        result: 1
