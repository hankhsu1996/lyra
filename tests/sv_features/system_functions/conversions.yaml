feature: conversion_functions
description: Tests for SystemVerilog conversion system functions ($signed, $unsigned, etc.)

cases:
  - name: signed_cast_basic
    sv: |
      module Test;
        logic [7:0] unsigned_val;
        logic signed [7:0] signed_result;
        initial begin
          unsigned_val = 8'hFF;  // 255 unsigned
          signed_result = $signed(unsigned_val);  // -1 signed
        end
      endmodule
    expect:
      variables:
        signed_result: -1

  - name: unsigned_cast_basic
    sv: |
      module Test;
        logic signed [7:0] signed_val;
        logic [7:0] unsigned_result;
        initial begin
          signed_val = -1;  // 0xFF in bits
          unsigned_result = $unsigned(signed_val);  // 255 unsigned
        end
      endmodule
    expect:
      variables:
        unsigned_result: 255

  - name: signed_preserves_bits
    sv: |
      module Test;
        logic [15:0] a;
        int result;
        initial begin
          a = 16'h8000;  // 32768 unsigned, -32768 if signed
          result = $signed(a);
        end
      endmodule
    expect:
      variables:
        result: -32768

  - name: signed_in_comparison
    sv: |
      module Test;
        logic [7:0] a, b;
        int result;
        initial begin
          a = 8'hFF;  // 255 unsigned, -1 if signed
          b = 8'h01;  // 1
          // Signed comparison: -1 > 1 is false
          result = ($signed(a) > $signed(b)) ? 1 : 0;
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: itor_basic
    sv: |
      module Test;
        int i;
        real r;
        initial begin
          i = 42;
          r = $itor(i);
          $display("%f", r);
        end
      endmodule
    expect:
      stdout: "42.000000\n"

  - name: itor_negative
    sv: |
      module Test;
        int i;
        real r;
        initial begin
          i = -123;
          r = $itor(i);
          $display("%f", r);
        end
      endmodule
    expect:
      stdout: "-123.000000\n"

  - name: rtoi_truncate_positive
    sv: |
      module Test;
        real r;
        int i;
        initial begin
          r = 3.7;
          i = $rtoi(r);
        end
      endmodule
    expect:
      variables:
        i: 3

  - name: rtoi_truncate_negative
    sv: |
      module Test;
        real r;
        int i;
        initial begin
          r = -3.7;
          i = $rtoi(r);
        end
      endmodule
    expect:
      variables:
        i: -3

  - name: realtobits_basic
    sv: |
      module Test;
        real r;
        bit [63:0] bits;
        initial begin
          r = 1.0;
          bits = $realtobits(r);
          $display("%h", bits);
        end
      endmodule
    expect:
      stdout: "3ff0000000000000\n"

  - name: bitstoreal_basic
    sv: |
      module Test;
        bit [63:0] bits;
        real r;
        initial begin
          bits = 64'h3ff0000000000000;  // IEEE 754 for 1.0
          r = $bitstoreal(bits);
          $display("%f", r);
        end
      endmodule
    expect:
      stdout: "1.000000\n"

  - name: realtobits_negative
    sv: |
      module Test;
        real r;
        bit [63:0] bits;
        initial begin
          r = -1.0;
          bits = $realtobits(r);
          $display("%h", bits);
        end
      endmodule
    expect:
      stdout: "bff0000000000000\n"

  - name: bitstoreal_roundtrip
    sv: |
      module Test;
        real r1, r2;
        bit [63:0] bits;
        initial begin
          r1 = 3.14159265358979;
          bits = $realtobits(r1);
          r2 = $bitstoreal(bits);
          $display("%f", r2);
        end
      endmodule
    expect:
      stdout: "3.141593\n"

  - name: shortrealtobits_basic
    sv: |
      module Test;
        shortreal r;
        bit [31:0] bits;
        initial begin
          r = 1.0;
          bits = $shortrealtobits(r);
          $display("%h", bits);
        end
      endmodule
    expect:
      stdout: "3f800000\n"

  - name: bitstoshortreal_basic
    sv: |
      module Test;
        bit [31:0] bits;
        shortreal r;
        initial begin
          bits = 32'h3f800000;  // IEEE 754 single for 1.0
          r = $bitstoshortreal(bits);
          $display("%f", r);
        end
      endmodule
    expect:
      stdout: "1.000000\n"

  - name: shortrealtobits_negative
    sv: |
      module Test;
        shortreal r;
        bit [31:0] bits;
        initial begin
          r = -1.0;
          bits = $shortrealtobits(r);
          $display("%h", bits);
        end
      endmodule
    expect:
      stdout: "bf800000\n"

  - name: bitstoshortreal_roundtrip
    sv: |
      module Test;
        shortreal r1, r2;
        bit [31:0] bits;
        initial begin
          r1 = 3.14159;
          bits = $shortrealtobits(r1);
          r2 = $bitstoshortreal(bits);
          $display("%f", r2);
        end
      endmodule
    expect:
      stdout: "3.141590\n"
