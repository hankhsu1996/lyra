feature: arbitrary_width_bit_vectors
description: Tests for bit vectors with widths 1-64 bits (indexing, ranges, element assignment)

cases:
  - name: bit_4_basic
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 5;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 5

  - name: bit_4_overflow
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 15;
          a = a + 1;  // Should wrap to 0
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_8_basic
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 200;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 200

  - name: bit_8_overflow
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 255;
          a = a + 1;  // Should wrap to 0
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_16_basic
    sv: |
      module Test;
        bit [15:0] a;
        int result;
        initial begin
          a = 12345;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 12345

  - name: bit_5_arithmetic
    sv: |
      module Test;
        bit [4:0] a, b, c;
        int result;
        initial begin
          a = 10;
          b = 20;
          c = a + b;  // 30 & 0x1F = 30
          result = c;
        end
      endmodule
    expect:
      variables:
        result: 30

  - name: bit_5_overflow_arithmetic
    sv: |
      module Test;
        bit [4:0] a, b, c;
        int result;
        initial begin
          a = 20;
          b = 20;
          c = a + b;  // 40 & 0x1F = 8
          result = c;
        end
      endmodule
    expect:
      variables:
        result: 8

  - name: logic_signed_4bit
    sv: |
      module Test;
        logic signed [3:0] a;
        int result;
        initial begin
          a = -5;  // 4-bit: 1011 = -5
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -5

  - name: logic_signed_4bit_comparison
    sv: |
      module Test;
        logic signed [3:0] a, b;
        int result;
        initial begin
          a = -8;  // Minimum 4-bit signed value
          b = 7;   // Maximum 4-bit signed value
          result = (a < b) ? 1 : 0;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_12_bitwise
    sv: |
      module Test;
        bit [11:0] a, b, c;
        int result;
        initial begin
          a = 12'hABC;
          b = 12'h123;
          c = a & b;
          result = c;
        end
      endmodule
    expect:
      variables:
        result: "0x20" # 0xABC & 0x123

  - name: bit_24_basic
    sv: |
      module Test;
        bit [23:0] a;
        int result;
        initial begin
          a = 24'hCAFE12;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: "0xcafe12"

  - name: bit_48_basic
    sv: |
      module Test;
        bit [47:0] a;
        longint result;
        initial begin
          a = 48'hDEADBEEF1234;
          result = longint'(a);
        end
      endmodule
    expect:
      variables:
        result: "0xdeadbeef1234"

  - name: bit_63_basic
    sv: |
      module Test;
        bit [62:0] a;
        longint result;
        initial begin
          a = 63'h7FFFFFFFFFFFFFF0;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: "0x7ffffffffffffff0"

  - name: bit_7_shift
    sv: |
      module Test;
        bit [6:0] a;
        int result;
        initial begin
          a = 7'b1010101;  // 85
          a = a << 2;      // Should mask to 7 bits
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 84 # (85 << 2) & 0x7F

  - name: byte_type
    sv: |
      module Test;
        byte a;
        int result;
        initial begin
          a = -100;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -100

  - name: shortint_type
    sv: |
      module Test;
        shortint a;
        int result;
        initial begin
          a = -30000;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: -30000

  - name: bit_2_basic
    sv: |
      module Test;
        bit [1:0] a;
        int result;
        initial begin
          a = 3;
          a = a + 1;  // Should wrap: 3 + 1 = 0 (mod 4)
          result = int'(a);
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: size_cast_truncation
    sv: |
      module Test;
        bit [3:0] val4;
        bit [7:0] val8;
        int result;
        initial begin
          val8 = 255;
          val4 = 4'(val8);  // Explicit size cast to truncate to 4 bits
          result = int'(val4);
        end
      endmodule
    expect:
      variables:
        result: 15

  - name: size_cast_extension
    sv: |
      module Test;
        bit [3:0] val4;
        bit [7:0] val8;
        int result;
        initial begin
          val4 = 4'hF;
          val8 = 8'(val4);  // Extend to 8 bits
          result = int'(val8);
        end
      endmodule
    expect:
      variables:
        result: 15

  # Bit indexing tests
  - name: bit_index_constant
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10101010;  // 0xAA = 170
          result = a[1];    // Bit 1 is 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_index_zero
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10101010;
          result = a[0];    // Bit 0 is 0
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: bit_index_high
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b10000000;  // 128
          result = a[7];    // Bit 7 is 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: bit_index_arithmetic
    sv: |
      module Test;
        bit [7:0] a;
        int sum;
        initial begin
          a = 8'b11001010;  // 0xCA
          sum = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7];
          // Bits: 0+1+0+1+0+0+1+1 = 4
        end
      endmodule
    expect:
      variables:
        sum: 4

  - name: bit_index_conditional
    sv: |
      module Test;
        bit [3:0] a;
        int result;
        initial begin
          a = 4'b1010;
          result = a[3] ? 100 : 200;  // Bit 3 is 1, so result = 100
        end
      endmodule
    expect:
      variables:
        result: 100

  # Range select tests
  - name: range_select_nibble
    sv: |
      module Test;
        bit [7:0] data;
        bit [3:0] high_nibble;
        int result;
        initial begin
          data = 8'hAB;
          high_nibble = data[7:4];
          result = high_nibble;
        end
      endmodule
    expect:
      variables:
        result: "0xa"

  - name: range_select_low
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'hAB;
          result = data[3:0];
        end
      endmodule
    expect:
      variables:
        result: "0xb"

  - name: range_select_middle
    sv: |
      module Test;
        bit [15:0] data;
        int result;
        initial begin
          data = 16'hABCD;
          result = data[11:4];  // Extract 0xBC
        end
      endmodule
    expect:
      variables:
        result: "0xbc"

  - name: range_select_single_bit
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'b10101010;  // 0xAA: bits 7,5,3,1 are set
          result = data[5:5];  // Single bit at position 5 (which is 1)
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: range_select_full_width
    sv: |
      module Test;
        bit [7:0] data;
        int result;
        initial begin
          data = 8'hCA;
          result = data[7:0];  // Full width select
        end
      endmodule
    expect:
      variables:
        result: "0xca"

  # Non-zero-based range tests
  - name: nonzero_base_declaration
    sv: |
      module Test;
        bit [63:32] x;
        int result;
        initial begin
          x = 32'hDEADBEEF;
          result = x;
        end
      endmodule
    expect:
      variables:
        result: -559038737 # 0xDEADBEEF as signed int

  - name: nonzero_base_bit_index_lsb
    sv: |
      module Test;
        bit [63:32] x;
        int result;
        initial begin
          x = 32'hAAAA5555;
          result = x[32];  // LSB (bit 0 of storage)
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: nonzero_base_bit_index_msb
    sv: |
      module Test;
        bit [63:32] x;
        int result;
        initial begin
          x = 32'h80000000;
          result = x[63];  // MSB (bit 31 of storage)
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: nonzero_base_bit_index_middle
    sv: |
      module Test;
        bit [63:32] x;
        int result;
        initial begin
          x = 32'h00001000;  // Bit 44 = bit 12 of storage
          result = x[44];
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: nonzero_base_range_select
    sv: |
      module Test;
        bit [63:32] x;
        int result;
        initial begin
          x = 32'hABCD1234;
          result = x[47:40];  // Extract byte at positions 47:40 = bits 15:8 of storage
        end
      endmodule
    expect:
      variables:
        result: "0x12"

  - name: nonzero_base_variable_index
    sv: |
      module Test;
        bit [10:5] x;
        int i;
        int result;
        initial begin
          x = 6'b101010;  // 42
          i = 7;
          result = x[i];  // Access bit 7 (storage bit 2) = 0
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: nonzero_base_small_range
    sv: |
      module Test;
        bit [5:2] x;  // 4-bit vector with range 5:2
        int result;
        initial begin
          x = 4'b1010;  // x[5]=1, x[4]=0, x[3]=1, x[2]=0
          result = x[3];  // Bit 3 = 1
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: nonzero_base_range_sum
    sv: |
      module Test;
        bit [10:5] x;
        int sum;
        initial begin
          x = 6'b110011;  // x[10]=1, x[9]=1, x[8]=0, x[7]=0, x[6]=1, x[5]=1
          sum = x[5] + x[6] + x[7] + x[8] + x[9] + x[10];
        end
      endmodule
    expect:
      variables:
        sum: 4 # 1+1+0+0+1+1

  - name: nonzero_base_negative_range
    sv: |
      module Test;
        bit [3:-4] x;  // 8-bit vector, indices 3 down to -4
        int lsb, msb;
        initial begin
          x = 8'b10101010;
          lsb = x[-4];  // LSB (storage bit 0) = 0
          msb = x[3];   // MSB (storage bit 7) = 1
        end
      endmodule
    expect:
      variables:
        lsb: 0
        msb: 1

  - name: negative_range_slice_across_zero
    sv: |
      module Test;
        bit [3:-4] c;  // 8 bits: indices 3,2,1,0,-1,-2,-3,-4
        int result;
        initial begin
          c = 8'b11001010;  // bits at positions 3,2,1,0,-1,-2,-3,-4
          result = c[1:-2];  // Extract bits at positions 1,0,-1,-2 = 0010
        end
      endmodule
    expect:
      variables:
        result: 2

  - name: negative_range_2d_element_access
    sv: |
      module Test;
        bit [1:-1][7:0] b;  // 3 elements with indices 1, 0, -1
        int r1, r0, r_neg1;
        initial begin
          b[1] = 8'hAA;
          b[0] = 8'hBB;
          b[-1] = 8'hCC;
          r1 = b[1];
          r0 = b[0];
          r_neg1 = b[-1];
        end
      endmodule
    expect:
      variables:
        r1: "0xaa"
        r0: "0xbb"
        r_neg1: "0xcc"

  # Element assignment tests
  - name: element_assign_set_bit
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b00000000;
          a[3] = 1;  // Set bit 3
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 8 # bit 3 set

  - name: element_assign_clear_bit
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 8'b11111111;
          a[5] = 0;  // Clear bit 5
          result = a;
        end
      endmodule
    expect:
      variables:
        result: "0xdf" # 0xFF with bit 5 clear

  - name: element_assign_multiple_bits
    sv: |
      module Test;
        bit [7:0] a;
        int result;
        initial begin
          a = 0;
          a[0] = 1;
          a[2] = 1;
          a[4] = 1;
          a[6] = 1;
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 85 # 0b01010101

  - name: element_assign_variable_index
    sv: |
      module Test;
        bit [7:0] a;
        int i;
        int result;
        initial begin
          a = 0;
          i = 4;
          a[i] = 1;  // Set bit 4
          result = a;
        end
      endmodule
    expect:
      variables:
        result: 16

  - name: element_assign_nonzero_base
    sv: |
      module Test;
        bit [10:5] x;  // 6-bit vector with range 10:5
        int result;
        initial begin
          x = 0;
          x[7] = 1;  // Set bit 7 (storage bit 2)
          result = x;
        end
      endmodule
    expect:
      variables:
        result: 4 # bit 2 of storage set
