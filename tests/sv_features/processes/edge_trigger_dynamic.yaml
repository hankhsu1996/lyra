feature: dynamic-index edge triggers via late-bound subscription rebinding
description: >
  Edge triggers on packed bit-selects with dynamic (runtime variable) index.
  @(posedge bus[i]) where i is a design-state or local variable. At suspend time,
  codegen evaluates i and computes the concrete bit target. If i is design-state,
  runtime creates a rebind subscription that re-targets the edge subscription when
  i changes.

cases:
  - name: posedge_dynamic_bit_select
    description: "@(posedge bus[i]) with i=3 wakes when bit 3 transitions 0->1"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: negedge_dynamic_bit_select
    description: "@(negedge bus[i]) with i=3 detects 1->0 on bit 3"
    sv: |
      module Test;
        logic [7:0] bus = 8'b0000_1000;
        int i = 3;
        int result = 0;
        initial begin
          @(negedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_0000;
      endmodule
    expect:
      variables:
        result: 1

  - name: no_false_trigger
    description: "change a different bit from the one being watched; must NOT wake"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial begin
          #5 bus = 8'b0000_0001;
          #5 bus = 8'b0000_1000;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: event_list_with_dynamic
    description: "@(posedge clk or posedge bus[i]) -- clk fires first"
    sv: |
      module Test;
        bit clk = 0;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge clk or posedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 clk = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: dynamic_index_changes_between_waits
    description: "i changes between consecutive waits; second wait targets new bit"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = result + 1;
          i = 0;
          @(posedge bus[i]);
          result = result + 1;
          $finish;
        end
        initial begin
          #5 bus = 8'b0000_1000;
          #5 bus = 8'b0000_1001;
        end
      endmodule
    expect:
      variables:
        result: 2

  - name: same_delta_rebind
    description: "i and bus change in same delta; rebind-first semantics"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial begin
          #5;
          i = 5;
          bus = 8'b0010_0000;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: oob_index_no_trigger
    description: "i out of range -> no spurious trigger, then finish via separate path"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 100;
        int result = 0;
        initial begin
          fork
            begin
              @(posedge bus[i]);
              result = 1;
            end
            begin
              #5 bus = 8'hFF;
              #10 $finish;
            end
          join_any
        end
      endmodule
    expect:
      variables:
        result: 0

  - name: oob_then_inrange
    description: "i goes OOB then returns in-range; triggering works again"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 100;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial begin
          #5 i = 3;
          #5 bus = 8'b0000_1000;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: local_index
    description: "i is a local variable; works without rebinding"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int result = 0;
        initial begin
          int i = 3;
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: odd_width_index
    description: "24-bit index (non-power-of-2 byte_size=3) works correctly"
    sv: |
      module Test;
        logic [31:0] bus = 0;
        logic [23:0] i = 24'd3;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 bus = 32'b0000_0000_0000_0000_0000_0000_0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: unsigned_high_bit_index
    description: "unsigned 8-bit index >= 128 is not treated as negative"
    sv: |
      module Test;
        bit [255:0] bus = 0;
        bit [7:0] i = 8'd200;
        int result = 0;
        initial begin
          @(posedge bus[i]);
          result = 1;
          $finish;
        end
        initial #5 bus[200] = 1'b1;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_add
    description: "@(posedge bus[i+j]) with two design-state variables"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 2;
        int j = 1;
        int result = 0;
        initial begin
          @(posedge bus[i+j]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_mul_const
    description: "@(posedge bus[i*2]) with variable * constant"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i*2]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0100_0000;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_add_const
    description: "@(posedge bus[i+1]) with variable + constant"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 2;
        int result = 0;
        initial begin
          @(posedge bus[i+1]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_multi_dep_change
    description: "i and j both change in same delta; epoch guard ensures single rebind"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 0;
        int j = 0;
        int result = 0;
        initial begin
          @(posedge bus[i+j]);
          result = 1;
          $finish;
        end
        initial begin
          #5;
          i = 2;
          j = 1;
          bus = 8'b0000_1000;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: dynamic_part_select_up
    description: "@(posedge bus[i +: 4]) ascending part-select, LSB = bus[i]"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 3;
        int result = 0;
        initial begin
          @(posedge bus[i +: 4]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: dynamic_part_select_down
    description: "@(posedge bus[i -: 4]) descending part-select, LSB = bus[i-(w-1)]"
    sv: |
      module Test;
        logic [7:0] bus = 0;
        int i = 6;
        int result = 0;
        initial begin
          @(posedge bus[i -: 4]);
          result = 1;
          $finish;
        end
        initial #5 bus = 8'b0000_1000;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_dynamic_unpacked_1bit
    description: "@(posedge arr[i]) with 1-bit elements, ascending range"
    sv: |
      module Test;
        logic arr [0:3];
        int i = 2;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial #5 arr[2] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: posedge_dynamic_unpacked_multibit
    description: "@(posedge arr[i]) with 8-bit elements, ascending range"
    sv: |
      module Test;
        logic [7:0] arr [0:3];
        int i = 1;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial #5 arr[1] = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: compound_index_unpacked
    description: "@(posedge arr[i+j]) compound index on unpacked array"
    sv: |
      module Test;
        logic arr [0:3];
        int i = 1;
        int j = 1;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i+j]);
          result = 1;
          $finish;
        end
        initial #5 arr[2] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: descending_range_unpacked_high
    description: "@(posedge arr[i]) descending range, i=3 maps to physical elem 0"
    sv: |
      module Test;
        logic arr [3:0];
        int i = 3;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial #5 arr[3] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: descending_range_unpacked_low
    description: "@(posedge arr[i]) descending range, i=0 maps to physical elem 3"
    sv: |
      module Test;
        logic arr [3:0];
        int i = 0;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial #5 arr[0] = 1;
      endmodule
    expect:
      variables:
        result: 1

  - name: descending_multibit_lsb
    description: "descending + multi-bit: toggle LSB triggers, toggle bit 1 does not"
    sv: |
      module Test;
        logic [7:0] arr [3:0];
        int i = 0;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial begin
          #5 arr[0] = 8'h02;
          #5 arr[0] = 8'h01;
        end
      endmodule
    expect:
      variables:
        result: 1

  - name: local_index_unpacked
    description: "local variable index on unpacked array; no rebinding needed"
    sv: |
      module Test;
        logic [7:0] arr [0:3];
        int result = 0;
        initial begin
          int i = 2;
          arr = '{0, 0, 0, 0};
          @(posedge arr[i]);
          result = 1;
          $finish;
        end
        initial #5 arr[2] = 8'h01;
      endmodule
    expect:
      variables:
        result: 1

  - name: oob_unpacked_inactive
    description: "OOB dynamic index silently deactivates (no crash, no false wake)"
    sv: |
      module Test;
        logic arr [0:3];
        int i = 100;
        int result = 0;
        initial begin
          arr = '{0, 0, 0, 0};
          fork
            begin
              @(posedge arr[i]);
              result = 1;
            end
            begin
              #5 arr[0] = 1;
              #5 arr[1] = 1;
              #5 arr[2] = 1;
              #5 arr[3] = 1;
              #10 $finish;
            end
          join_any
        end
      endmodule
    expect:
      variables:
        result: 0
