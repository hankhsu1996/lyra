feature: wait_event
description: Tests for event control and sensitivity lists (LRM 9.4.2)

cases:
  - name: always_comb_runs_once_at_time_zero
    sv: |
      module Test;
        int a, b, c;
        initial begin
          a = 1;
          b = 2;
        end

        always_comb c = a + b;
      endmodule
    expect:
      variables:
        c: 3
      time: 0

  - name: always_comb_reacts_to_input_change
    sv: |
      module Test;
        int a, b, c;
        initial begin
          a = 1;
          b = 2;
          #5 a = 3;
        end

        always_comb c = a + b;
      endmodule
    expect:
      variables:
        c: 5
      time: 5

  - name: wait_until_change
    sv: |
      module Test;
        int a;
        initial begin
          @(a);
        end

        initial #5 a = 1;
      endmodule
    expect:
      variables:
        a: 1
      time: 5

  - name: wait_then_delay
    sv: |
      module Test;
        int a;
        initial begin
          @(a);
          #2;
        end

        initial #5 a = 1;
      endmodule
    expect:
      variables:
        a: 1
      time: 7

  - name: posedge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(posedge clk);
          seen = 1;
        end

        initial begin
          clk = 0;
          #5 clk = 1;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: negedge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(negedge clk);
          seen = 1;
        end

        initial begin
          clk = 1;
          #5 clk = 0;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: edge_trigger
    sv: |
      module Test;
        int clk, seen;
        initial begin
          @(edge clk);
          seen = 1;
        end

        initial begin
          clk = 0;
          #5 clk = 1;
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: always_ff_posedge
    sv: |
      module Test;
        int clk, q;
        initial clk = 0;

        always_ff @(posedge clk) q = 42;

        initial begin
          #2 clk = 1;
          #2 clk = 0;
          #2 clk = 1;
        end
      endmodule
    expect:
      variables:
        q: 42
      time: 6

  - name: always_latch_behavior
    sv: |
      module Test;
        int a, b, q;
        always_latch begin
          if (a > 0)
            q = a + b;
        end

        initial begin
          a = 1; b = 2;
          #5 a = 0;
        end
      endmodule
    expect:
      variables:
        q: 3
      time: 5

  - name: correct_posedge_count
    sv: |
      module Test;
        bit a;
        int count;

        always_ff @(posedge a) begin
          count = count + 1;
        end

        initial begin
          a = 0;
          #5 a = 1;
          #5 a = 0;
          #5 a = 1;
          #5 a = 0;
        end
      endmodule
    expect:
      variables:
        count: 2
      time: 20

  - name: any_change_string_trigger
    sv: |
      module Test;
        string s;
        int seen;
        initial begin
          @(s);
          seen = 1;
        end

        initial begin
          s = "abc";
          #3 s = "def";
        end
      endmodule
    expect:
      variables:
        seen: 1
      time: 3

  - name: posedge_or_negedge_trigger_first_edge
    description: |
      Test that @(posedge clk or negedge rst) triggers on posedge clk.
      Regression test for edge kind overwrite bug where wait_set_ key
      didn't include variable, causing last edge kind to overwrite previous.
    sv: |
      module Test;
        bit clk, rst;
        int seen;
        initial begin
          clk = 0;
          rst = 1;
          @(posedge clk or negedge rst);
          seen = 1;
        end

        initial #5 clk = 1;
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: posedge_or_negedge_trigger_second_edge
    description: |
      Test that @(posedge clk or negedge rst) triggers on negedge rst.
    sv: |
      module Test;
        bit clk, rst;
        int seen;
        initial begin
          clk = 0;
          rst = 1;
          @(posedge clk or negedge rst);
          seen = 1;
        end

        initial #5 rst = 0;
      endmodule
    expect:
      variables:
        seen: 1
      time: 5

  - name: large_sensitivity_list_inline
    description: |
      Test always_comb with 32 inputs (at the inline capacity limit).
      Verifies the inline trigger storage path works correctly.
    sv: |
      module Test;
        int a0, a1, a2, a3, a4, a5, a6, a7;
        int a8, a9, a10, a11, a12, a13, a14, a15;
        int a16, a17, a18, a19, a20, a21, a22, a23;
        int a24, a25, a26, a27, a28, a29, a30, a31;
        int sum;

        always_comb sum = a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 +
                          a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 +
                          a16 + a17 + a18 + a19 + a20 + a21 + a22 + a23 +
                          a24 + a25 + a26 + a27 + a28 + a29 + a30 + a31;

        initial begin
          a0 = 1; a1 = 1; a2 = 1; a3 = 1; a4 = 1; a5 = 1; a6 = 1; a7 = 1;
          a8 = 1; a9 = 1; a10 = 1; a11 = 1; a12 = 1; a13 = 1; a14 = 1; a15 = 1;
          a16 = 1; a17 = 1; a18 = 1; a19 = 1; a20 = 1; a21 = 1; a22 = 1; a23 = 1;
          a24 = 1; a25 = 1; a26 = 1; a27 = 1; a28 = 1; a29 = 1; a30 = 1; a31 = 1;
        end
      endmodule
    expect:
      variables:
        sum: 32
      time: 0

  - name: large_sensitivity_list_overflow
    description: |
      Test always_comb with 40 inputs (exceeds inline capacity of 32).
      Verifies the heap-allocated trigger storage path works correctly.
    sv: |
      module Test;
        int a0, a1, a2, a3, a4, a5, a6, a7;
        int a8, a9, a10, a11, a12, a13, a14, a15;
        int a16, a17, a18, a19, a20, a21, a22, a23;
        int a24, a25, a26, a27, a28, a29, a30, a31;
        int a32, a33, a34, a35, a36, a37, a38, a39;
        int sum;

        always_comb sum = a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 +
                          a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 +
                          a16 + a17 + a18 + a19 + a20 + a21 + a22 + a23 +
                          a24 + a25 + a26 + a27 + a28 + a29 + a30 + a31 +
                          a32 + a33 + a34 + a35 + a36 + a37 + a38 + a39;

        initial begin
          a0 = 1; a1 = 1; a2 = 1; a3 = 1; a4 = 1; a5 = 1; a6 = 1; a7 = 1;
          a8 = 1; a9 = 1; a10 = 1; a11 = 1; a12 = 1; a13 = 1; a14 = 1; a15 = 1;
          a16 = 1; a17 = 1; a18 = 1; a19 = 1; a20 = 1; a21 = 1; a22 = 1; a23 = 1;
          a24 = 1; a25 = 1; a26 = 1; a27 = 1; a28 = 1; a29 = 1; a30 = 1; a31 = 1;
          a32 = 1; a33 = 1; a34 = 1; a35 = 1; a36 = 1; a37 = 1; a38 = 1; a39 = 1;
        end
      endmodule
    expect:
      variables:
        sum: 40
      time: 0
